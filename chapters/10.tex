\chapter{用户数据报协议和 IP 分片}
\minitoc

\section{引言}
UDP是一种保留消息边界的简单的面向数据报的传输层协议。它不提供差错纠正、队
列管理、重复消除、流量控制和拥塞控制。它提供差错检测，包含我们在传输层中碰到的第
一个真实的端到端（end-to-end）校验和。这种协议自身提供最小功能，因此使用它的应用程
序要做许多关于数据包如何发送和处理的控制工作。想要保证数据被可靠投递或正确排序，
应用程序必须自己实现这些保护功能。一般来说，每个被应用程序请求的 UDP 输出操作只
产生一个 UDP 数据报，从而发送一个IP数据报。这不同于面向数据流的协议，例如TCP
（见第15章），应用程序写人的全部数据与真正在单个IP数据报里传送的或接收方接收的内
容可能没有联系。

［RFC0768］是UDP的正式规范，它至今仍然是一个标准，30多年来没有做过重大的修
改。如前所述，UDP 不提供差错纠正：它把应用程序传给IP层的数据发送出去，但是并不
保证它们能够到达目的地。另外，没有协议机制防止高速 UDP流量对其他网络用户的消极
影响。考虑到这种可靠性和保护性的缺失，我们可能会认为使用UDP一点好处也没有。但
是，这是不对的。因为它的无连接特征，它要比其他的传输协议使用更少的开销。另外，广
播和组播操作（见第9章）更多直接使用像 UDP这样的无连接传输。最后，应用程序可选择
自己的重传单元的能力是一项重要的考虑（例如，见 ［CT90］）。
% \begin{figure}[ht]
%     \centering
% 	\includegraphics[width=0.7\textwidth]{imgs/10/10-1.png}
% 	\caption{单个 IPv4数据报中的UDP数据报封装（通常情况下没有IPv4选项）。IPv6 封装是类似的，UDP头部跟随在头部链之后}
% \end{figure}

图10-1显示了一个 UDP数据报作为单个 IPv4 数据报的封装。IPv6的封装是类似的，
但是一些细节有少许不同，我们在10.5节讨论它们。IPv4 协议（Protocol）字段用值17来标
识UDP。IPv6则在下一个头部（Next Header） 字段使用相同的值。在本章稍后我们将探讨当
UDP 数据报大小超过MTU 时会发生什么，数据报必须被分片成多于一个的IP 层分组。

\section{UDP 头部}

图10-2显示了一个包含负载和UDP 头部（通常是8字节）的UDP数据报。

端口号相当于邮箱（mailbox），帮助协议辨认发送和接收进程（见第1章）。它们纯属抽
象的（abstract）—-它们不与主机上的任何物理实体相关。在UDP 中，端口号是正的16比
特的数字，源端口号是可选的；\emph{如果数据报的发送者不要求对方回复的话，它可被置成0。}
传输协议，如 TCP、UDP 和SCTP［RFC4960］，使用目的端口来帮助分离从IP 层进入的数据。
因为IP 层根据IPv4头部中的协议字段或IPv6头部中的下一个头部字段的值将进入的IP 数
据报分离到特定的传输协议，这意味着端口号在不同的传输协议之间是独立的。也就是说，
TCP端口号只能被 TCP使用，UDP 端口号只能被 UDP使用，如此类推。这样的分离导致的
一个直接结果是\emph{两个完全不同的服务器可以使用相同的端口号和 IP 地址，只要它们使用不
同的传输协议。}

图10-2 UDP 头部和负载（数据）区。校验和（Checksum）字段是端到端的，是对包含了IP 头部中的
源（Source）和目的 IP 地址 （Destination Address）字段的UDP伪头部计算得到的。因此，任
何对这些字段的修改（如，由 NAT）都需要对 UDP 校验和进行修改

\begin{tcolorbox}    
    尽管有这种独立性，但是如果某个众所周知的服务可同时由TCP 和UDP提
    供（或者可信服地提供），那么这两个传输协议的端口号通常被分配成一样的。关
    于如何规范地分配端口号，详见［IPORT］。
\end{tcolorbox}

参考图 10-2，UDP 长度（Length）字段是UDP头部和 UDP数据的总长度，以字节
单位。这个字段的最小值是8，除非使用了带有 IPv6 超长数据报（jumbogram）的UDP（见
节）。发送一个带0字节数据的UDP数据报是允许的，尽管这很少见。值得注意的是
UDP 长度字段是冗余的；IPv4头部包含了数据报的总长度（见第5章），同时IPv6头部包含
了负载长度。因此，一个 UDP/IPv4数据报的长度等于IPv4数据报的总长度减去IPv4 头部
的长度。一个 UDP/IPv6数据报的长度等于包含在IPv6 头部中的负载长度（Payload Length）
字段的值减去所有扩展头部（除非使用了超长数据报）的长度。在这两种情况下，UDP 长度
字段的值应该与从IP 层提供的信息计算得到的长度是一致的。

\section{UDP 校验和}
UDP 校验和是我们遇到的第一个端到端的传输层校验和（ICMP有一个端到端的校验
和，但它不是一个真正的传输协议）。它覆盖了 UDP头部、UDP 数据和一个伪头部（在本节
稍后有定义）。它由初始的发送方计算得到，由最终的目的方校验。它在传送中不会被修改
（除非它通过一个 NAT，如第7章所述）。回想一下\emph{ IPv4 头部中的校验和只覆盖整个头部（即
它并不覆盖IP 分组中的任何数据），它在每个IP 跳都要被重新计算（因为 IPv4 TTL字段的
值在数据报转发时会被路由器减少）。}传输协议（如 TCP、UDP）使用校验和来覆盖它们的
头部和数据。对于UDP来说，校验和是可选的（尽管强烈推荐使用），而其他的则是强制的。
当UDP在IPv6 中使用时，校验和的计算与使用是强制的，因为在IP 层没有头部校验和。
为了给应用程序提供无差错数据，像UDP这样的传输层协议，在投递数据到接收方应用程
序之前，必须计算校验和或者使用其他差错检测机制。

虽然计算 UDP 校验和的基本方法与我们在第5章描述的普通互联网校验和（16位字的
反码和的反码）类似，但是要注意两个小的细节。首先，UDP 数据报长度可以是奇数个字节，
而校验和算法只相加16位字（总是偶数个字节）。UDP 的处理过程是在奇数长度的数据报尾
部追加一个值0的填充（虚）字节，这仅仅是为了校验和的计算与验证。这个填充字节实
际上是不会被传送出去的，因此在这里称之为“虚”的。

第二个细节是 UDP（也包括TCP）计算它的校验和时包含了（仅仅）衍生自IPV4头部的
字段的一个12字节的伪头部或衍生自IPv6 头部的字段的一个40字节的伪头部。这个伪头
部也是虚的，它的目的只是用于校验和的计算（在发送方和接收方）。实际上，它从来不会
被传送出去。这个伪头部包含了来自IP 头部的源和目的地址以及协议或下一个头部字段（它
的值应该是17）。它的目的是让UDP层验证数据是否已经到达正确的目的地（即，该IP没
有接受地址错误的数据报，也没有给UDP一个本该是其他传输协议的数据报）。图10-3显
示了计算 UDP 校验和时覆盖的字段，包含了伪头部以及UDP 头部和负载。

图 10-3 用于计算 UDP/IPv4数据报的字段，包含了伪头部、UDP 头部和数据。如果数据不是偶数个
字节长，它会被填充一个值为0的字节以计算校验和。伪头部和任何填充的数据不会与数据
报一起被传送出去


\begin{tcolorbox}    
    细心的读者会发现这会导致所谓的“违反分层”（layering violation）规则。
    即，UDP 协议（传输层）直接操作IP（网络层）的比特。没错，但这只对协议实现
    产生微小的影响，因为一般来说，当数据传递到（或来自于）UDP 时，IP 层的信息
    已经是现成的了。相比之下，更应该关注 NAT（见第7章），特别是当 UDP 数据报
    被分片时。
\end{tcolorbox}

图10-3显示了一个数据是奇数长度的数据报需要一个填充字节来完成校验和的计算。
注意到 UDP数据报的长度在校验和的计算中出现了两次。如果计算出来的校验和的值正好
是0x0000，它在头部中会被保存成全1（0xFFFF），等于算术反码（见第5章）。一旦被接收，
校验和字段值为0x0000表示发送方没有计算校验和。如果发送方的确计算了校验和，而接
收方也检测到一个校验差错，UDP数据报就会被毫无声息地放弃。尽管会有一些统计计数被
更新，但却没有差错消息产生。（这就是一个 IPv4 头部校验差错被检测到时会发生的事情。）

尽管UDP数据报校验和在原始UDP规范中是可选的，目前它们还是被要求在主机中
默认使用［RFC1122］。在20世纪80年代，一些计算机供应商默认关闭了 UDP校验和功能
以加速其 Sun 网络文件系统（NFS）的实现，该网络文件系统使用了 UDP。因为有第2层的
CRC保护（这要比互联网校验和更强壮，见第3章），在许多情况下这可能不会产生问题，
然而默认关闭校验和功能被认是一种不好的方法（也是违反 RFC规范的）。早期的互联网
经验表明，当数据报通过路由器时，关于它们的正确性的所有赌注都会失败。信不信由你，
总会存在有软件和硬件漏洞的路由器在转发数据报时会修改其中的比特。如果端到端的UDP
校验和被关闭的话，这些UDP数据报中的错误就无法检测到。同时注意到一些更老的数据
链路协议（比如，串行线IP 或SLIP）没有任何形式的数据链路校验和，因此存在IP 分组被
修改而检测不到的可能性，除非引人另一种校验和。

\begin{tcolorbox}
    ［RFC1122］要求UDP校验和被默认使用。它也指出如果发送方计算了校验
    和（也就是说，如果接收到的校验和不是0），那么必须要有一种实现来验证接收到
    的校验和。
\end{tcolorbox}

考虑到伪头部这样的结构，可以很清楚地看到，当一个 UDP/IPv4数据报穿过一个 NAT
时，不仅IP 层头部的校验和要被修改，而且UDP 伪头部的校验和也必须被正确地修改，因
为IP 层的地址和/或UDP层的端口号可能会改变。因此 NAT通常因同时修改分组中协议的
多层而违反分层规则。当然，考虑到伪头部本身就是违反分层规则的，NAT没有选择。UDP
流量被 NAT处理时的一些特定规则由［RFC4784］给出。在第7章我们也简单地讨论过它们。
近来已有兴趣关注于对 UDP校验和的松懈使用，主要是一些对差错不完全看重的应用
（多媒体应用是典型的例子）。这些讨论关系到是否有部分校验和（partial checksum），这是
一个很有价值的概念。部分校验和只覆盖由应用程序指定的负载的一部分。在10.6 节关于
UDP-Lite 的内容里我们再讨论它。

\section{例子}
我们将使用 sock程序［SOCK］来生成一些 UDP数据报，并且可以在 tcpdump 中查看它
们。在第一个例子里，我们在目标机器上的丢弃端口（9）运行着一个服务器。在第二个例
子里，我们关闭了服务器，客户机收到了这个事实的通知，像例子里显示的。出于安全考
虑，在典型的机器配置里，基于UDP 的服务极少是可用的，因此例子的第二部分并不少见。

\begin{verbatim}
    Linux% sock -v -u -i 10.0.0.3 discard
    connected on 10.0.0.5.46274 to 10.0.0.3
    wrote 1024 bytes
    ...                                             （1023 more times）

    Linux% sock -v -u -i 10.0.0.3 discard
    connected on 10.0.0.5.46294 to 10.0.0.3
    wrote 1 bytes
    write returned -1, expected 1024:Connection refused
\end{verbatim}

我们运行 sock 程序时，指定了详细模式-v 以查看用到的短暂端口号，u指定UDP而
非默认的TCP，同时使用-i选项去发送数据而不是尝试去读和写标准输人和输出。数据报个
数的默认值（1024）被发送到IP 地址为10.0.0.3的目标主机。在这个例子里，我们已经安排
了一个服务器去处理这些进人的数据报到丢弃端口。为了捕获已发送的流量，我们在一台有
流量流的主机上使用下面的命令：

\begin{verbatim}
    Linux# tcpdump -n -p -s 1500 -vv host 10.0.0.3 and \（ udp or icmp\）
\end{verbatim}

这个命令捕获这两台机器之间的任何UDP或ICMP流量（也有可能是其他在这里没列
出的机器的额外流量）。-s 1500选项指使 tcpdump 收集分组直到长度达到1500字节（这里，
比我们发送的1024字节要长），-vvv选项表明是详细打印输出。-n 选项告诉 tcpdump 不要把
IP 地址转换成主机名，-P选项避免把默认网络接口设置成混杂模式。tcpdump 的输出结果显
示在清单10-1中（为了简洁，某些行已被整理）。

清单 10-1

tcpdump 输出显示了来自第一个 sock命令（服务器正在运行）的数据分组
\begin{verbatim}
    1 22:52:53.102838 10.0.0.5.46274 > 10.0.0.3.9：
                    ［udp sum ok］udp 1024 （DF）（ttl 64,id 24462,len 1052）
    2 22:52:53.102964 10.0.0.5.46274 > 10.0.0.3.9：
                    ［udp sum ok］ udp 1024 （DF）（tt1 64,id 24463,len 1052）
    3 22:52:53.103091 10.0.0.5.46274 > 10.0.0.3.9：
                    ［udp sum ok］ udp 1024 （DF）（tt1 64,id 24464,len 1052）
    4 22:52:53.103215 10.0.0.5.46274>10.0.0.3.9：
                    ［udp sum ok］ udp 1024 （DF）（tt1 64,id 24465,len 1052）
    ...repeated 1020 times...
\end{verbatim}

这个输出显示了4个1052字节的 UDP/IPv4数据报（1024字节的UDP负载加上8字节
的UDP 头部和20字节的IPv4头部）来自IPv4地址10.0.0.5和端口 46274，被发送至端口
9（丢弃端口），分组间隔时间大概是100us。另外，我们可以观察到 UDP 校验和是被启用和
有效的（由tcpdump 校验），不分片（Don't Fragment,DF） 位字段是打开的，IPV4 TTL 字段
是64，IPV4 标识（Identification）字段对每个数据报都是不同的（逐个加1）。没有ICMP 流
量产生，并且似乎所有数据都成功投递到目的机器；因为没有确认，我们不能肯定。在第13
章我们应该会看到另一种主要的传输协议 TCP，通常在数据的第一个字节可被发送之前使用
一个与对方的握手和后续的确认来了解什么数据已经成功传送到接收方。

第二次我们使用相同的参数运行 sock程序，但是这次我们在服务器关闭后发送数据报
到丢弃服务。清单10-2显示了这个例子的流量跟踪信息（为了简洁，某些行已被整理）。

清单 10-2

tcpdump 输出显示了来自主机（服务器已关闭）的ICMP 目标不可到达（端口不可到达）消息

1 22:55:07.223094 10.0.0.5.46294> 10.0.0.3.9：

［udp sum ok］ udp 1024 （DF）（tt1 64,id 37874,len 1052）

2 22:55:07.223134 10.0.0.3>10.0.0.5: icmp：

\subsubsection{udp port 9 unreachable for}
\subsubsection{> 10.0.0.3.9：}
udP 1024 （DF）（tt1 64,id 37874,len 1052）

［tos Oxco］ （tt1 255,id 63302，len 576）

在这个例子里我们看到有些不同的行为。这里，只有单个 UDP数据报被发送，同时回
复中有一个ICMP 消息返回。尽管所有其他参数都是相同的，但是没有运行中的服务器来接
收这些传入的数据报。在这种情况下，UDP 的底层实现产生一个 ICMPv4 目标不可到达（端
口不可到达）消息（见第8章），并返回给发送方。这个消息包含原始（“违规”）的数据报最
前面的556字节的一个拷贝。如果这个ICMP 消息没被中间网络丢弃（由防火墙偶然或有目
的地），发送程序（如果ICMP 消息到达时它还在运行）就可以知道接收方不存在并打印错误
信息，如本节开头的清单所示（即消息 write returned-1）。值得注意的是返回的ICMP 错误
消息包含了充足的信息让发送主机确定哪个端口不可达。最后，应注意到UDP端口在程序
每次运行时都会改变。首先它是 46274，然后是46294。我们在第1章提到这些由客户机使
用的短暂端口号建议位于 49152 到65535 的范围，因此这里我们观察到非规范行为。

\begin{tcolorbox}
    对于Linux，本机端口参数范围可以很容易地通过改变文件 \verb|/proc/sys/net/ipv4/ip_local_port_range|
    的内容进行修改。在 Windows Vista及之后版本中，可以使用 netsh 命令设置动态端口范围［KB929851］。
    当前端口号见［IPORT］。
\end{tcolorbox}

\section{UDP 和 IPV6}
考虑到简单性，在对IPv6而非IPv4 进行操作时，UDP 只需做很小的改动。最明显的不
同就是IPv6使用128位的地址和由此产生的对伪头部的结构带来的影响。一个相关却更细
致的不同在于，在IPv6 里不存在IP 层头部校验和。因此，如果 UDP 不使用校验和去运行，
就没有端到端检测任何（no end-to-end check whatsoever）IP 层地址信息的正确性。鉴于此，
当UDP用于IPv6 时，无论是 UDP 还是TCP，伪头部校验和都是必需的（由［RFC2460］第
8节规定）。伪头部的结构由图10-4给出。注意到长度字段已经从它的IPv4 相应字段扩展到
32位。回想之前所述，这个字段对UDP来说是冗余的，但是我们可以从第13 章看到，对
TCP（无论是TCP/IPv4还是TCP/IPv6）来说它不是冗余的，因此在 UDP/IPv6 和 TCP/IPv6
中都保留了该字段。

图10-4 使用IPv6的UDP（以及TCP）伪头部（［RFC2460］）。这个伪头部包含了源和目的IPv6地址
以及一个更大的32位的长度字段值。UDP 用于IPv6 时，伪头部校验和是必需的，因为IPv6
头部缺少校验和。下一个头部字段拷贝于链中的最后一个 IPv6头部

扩展讨论一下IPv6分组长度，IPv6分组大小的两个方面会影响UDP。第一，在IPv6
里，最小MTU 大小是1280字节（与IPv4要求的需要所有主机支持的最小大小576字节不
同）。第二，IPv6 支持超长数据报（大于65 535字节的分组）。如果我们仔细查看IPv6 头部
和选项集（见第5章），可以观察到使用超长数据报，32位是能够表示负载长度的。这意味
着单个 UDP/IPv6数据报确实可以非常大。如［RFC2675］所述，对于 UDP头部中的只有16
位长的UDP 长度字段会产生一个问题。这样的话，超过65 535字节的UDP/IPv6 数据报被
封装在IPv6时，它的UDP 长度字段值会被置成0。注意到伪头部里的长度字段的大小仍然
足够大（32位）。对IPv6超长数据报计算这个字段的值，涉及取UDP 头部加上数据的总长
度。当收到一个分组检查这个字段时，涉及计算 UDP 数据报（头部加数据）的大小，通过在
Jumbo Payload选项中找到的值减去所有IPv6扩展头部的大小来得到，这也是IPv6负载的
长度（即数据报总长减40字节的IPv6头部）。在UDP头部中的长度字段是0且没有Jumbo
Payload选项存在的“意外的”情况下，UDP 长度可以从不等于零的IPv6负载长度字段中推
断得到（见［RFC2675］第4节）。

\subsection{Teredo：通过IPv4 网络隧道传输IPv6}
虽然以前人们认为全世界过渡到IPv6会很快发生，但是事实并不像预料的那样。结果
是，不少（理论上是暂时的）过渡机制（transition mechanism）［RFC4213］［RFC5969］被提
出来缓解过渡负担。其中一个叫 6to4 的机制［RFC3056］，把在主机使用的IPv6分组封装在
IPv4 分组里以在只支持 IPv4 的基础设施中传送。与其他互联网上的应用程序遇到过的问题
一样，6t04也遇到 NAT 穿越问题。另一个众所周知的扩展性问题使得人们不太愿意继续使
用它 ［RFC6343］。尽管我们已经看到一些像ICE（见第7章）的方法可以很好地解决这个问
题，但是一个名叫 Teredo（原来叫 “shipworm（船蛆）”，但是为了避免与计算机蠕虫混淆，
根据“船蛆”的常见类属的拉丁名字而重新命名）的专门协议已被设计出来专门解决这个问
题 ［RFC4380］［RFC5991］［RFC6081］。它之所以流行，是因为它在微软 Windows 的当代版本
中得到了广泛的应用。

Teredo（也叫Teredo隧道）为没有其他IPv6连接选项的系统传送IPv6 数据报，方法是把
IPv6数据报置于 UDP/IPv4数据报的负载区里。图10-5中给出了一个例子场景。Teredo 客户
机是实现了 Teredo隧道接口的IPv4/IPv6 主机。在成功通过一个“资格认证”过程（下一段有
介绍）之后，接口会被分配一个特定的以2001：：/32为 IPv6前缀的Teredo地址。与STUN服
务器（第7章）的作用类似，Teredo服务器用于帮助Teredo 封装的IPv6 分组建立直接通道以
穿越 NAT。Teredo 中继器（relay）与TURN服务器的作用类似，如果有大量客户在使用的话，
会消耗相当可观的处理资源。值得注意的是，服务器必须包括中继器的所有功能，反之则不
然。对IPv6连接来说，使用Teredo 中继器是“最后手段”。如果发现其他任何可选的IPv6 连
接（比如，直接连接或使用 6to4），节点就会放弃使用 Teredo 隧道技术。

参照图 10-5，Teredo 客户机使用主机名或 IPv4地址和某个 Teredo 服务器的UDP 端口
号（通常是3544）进行初始化配置。Tered。一开始是由微软开发的，并且有一个名內 teredo.
ipv6.microsoft.com 的Teredo服务器是可用的。当客户机准备获取一个地址时，它就开始资
格认证过程（qualification procedure）。客户机首先从使用它的Teredo 服务端口的一个本地链
路IPv6地址（link-local IPv6 address）发送一个ICMPv6 RS 分组（见第8章），代理则负责从
UDP/IPv4 封装和解封IPv6。封装格式是原始指示符格式，它是两种封装格式中的一种，如

Teredo，一种IPv6 过渡机制，在UDP/IPv4数据报的负载区中封装 IPv6 数据报和可选的追踪
符，以使IPv6流量能经过只支持IPv4的基础设施。服务器帮助客户机获得一个 IPv6地址并
决定它们的映射地址和端口号。如果需要，中继器在 Teredo、6t04 及原生IPv6 客户机间转发
流量

Teredo使用的简单封装和原始指示符封装。原始指示符封装在UDP 头部和被封装的IPv6 数
据报之间携带了 UDP地址和端口号信息。在产生一个 Teredo地址时，这些信息可以使得
Teredo 客户机知道它们的映射地址和端口号。地址和端口号被按位取反，从而显得“混乱”，
这是为了避免 NAT 试图去重写这些信息。可能存在零或多个追踪符，被编码成 TLV 三元组。
它们被用于实现许多 Teredo 扩展（比如支持对称 NAT）

力回应是一种ICMPv6 RA 消息，使用图10-6所示的原始指示符封装格式。RA 包

含一个前缀信息选项，该选项是一个有效的 Teredo 前缀（见第2章）。原始指示符为客户机

提供自身的映射地址和端口信息。RA 的源地址是服务器的一个有效的本地链路IPv6地址。

RA的目的地址是客户机用作RS消息源地址的本地链路IPv6地址。假设一切正常的话，客

户机现在是“有资格的”，并且可以根据服务器提供的前缀和原始信息来产生它的Teredo

IPv6地址。Teredo地址是一个 IPv6地址，使用图10-7所示的格式，由多个参数构成。

Teredo IPv6前缀

（32位）

- 128位的IPv6地址

服务器IPv4地址

（32位）

标志

（16位）

映射端口

（16位）

映射IPv4地址

（32位）

2001：：/32

Teredo服务器

客户机的（映射）地址

（对各位取补，以使其混乱）

图 10-7

由［RFC5991］

Randoml

Random2

指定

C

0

U

G

（4位）

（8位）

Teredo 客户机使用带 Teredo 前缀2001：：/32的IPv6地址。随后位包含了Teredo服务器的
IPv4 地址、16位标志（用于标识用到的 NAT类型和随机位以帮助阻止地址猜测攻击）、客户
机的16 位映射端口号，以及客户机的32位映射IPv4地址。最后两项是“混乱”的
一个 Teredo 地址（见图 10-7）包含Teredo前缀（2001：：/32）、Teredo服务器的IPv4地
址、一个16位的标志（Flags）字段（在下面详细介绍），然后是映射的端口号和映射的IPv4
地址。最后两项是从 Teredo服务器看到的客户机的地址信息，经常由客户机的最外层 NAT
决定。真实的地址和端口号信息是按位取反的，以使鲁莽的NAT 不去重写它们。
16位的标志字段用于标识在资格认证过程期间发现的 NAT类型。一些 NAT（正式叫法
是对称 NAT—具有地址依赖映射或地址和端口依赖映射，以及地址依赖或地址和端口依赖
过滤特性的 NAT）只有在扩展得到支持时才能使用Teredo（见本节后面），但是大多数普通
类型的家庭网络（包括“锥形（cone） NAT”—-具有终端独立映射和终端独立过滤特性的
NAT）不需要扩展的支持就可以工作。一开始，C（cone NAT）位字段是用于标识是否碰到一
个锥形 NAT并给予合适的支持，但现在这种用法被弃用，这个字段应该置成0（客户机忽略
这个字段，服务器检查它以寻找过时的客户机）。下一个位字段置成O。U（Universal）和G
（Group）位字段留给未来使用，但现在被置成0。根据［RFC5991］选择 Randoml 和 Random2
字段的随机值，从而使得 Teredo地址很难被猜到（一种安全的措施就是尽量减少潜在攻击者
的随机试探）。

一旦一个已取得资格的客户机建立了自己的Teredo 地址，它就可以发送IPv6 流量了。
至于资格认证失败会发生什么或使用一种安全资格认证的具体细节，可参见［RFC4380］。一
般来说，一台Teredo 客户机可能想要与另一台在同一链路中的客户机、另一台在IPV4 互联
网中的客户机或在IPv6互联网中的一台主机进行通信。在每种情况下，Teredo 会提供一些
基于 UDP/IPv4的邻居发现来取代IPv6。对于在同一链路中的客户机，Teredo使用一种组播
地址为224.0.0.253的IPv4组播发现协议。特殊的 Teredo“气泡”分组（那些不带数据负载
的分组）用于判断目的地址是否在同一链路中。这些气泡以最小大小的Teredo 分组出现，使
用图10-6中的简单封装格式。它们包含一个IPv6头部，其中目的IP地址字段被设这次
通信的目的地。这个IPv6 分组包含一个没有负载和附加扩展（下一个头部字段被置为0x3b，
表示为空）的IPv6头部。对于在IPv4 互联网中的客户机，回想一下 Teredo IPv6地址包含了
IPv4 映射地址和端口号，因此，客户机可直接发送Teredo封装的分组到其他客户机的NAT。
对于受限的 NAT，Teredo 使用气泡来打孔和建立 UDP NAT 映射（见第7章和［RFC6081］）。

当一个已取得资格认证的客户机有一个分组要发送到一台IPv6 主机（即一台没使用
Teredo 地址的主机）时，它首先判断是否已经知道一个负责该分组的目的地的Teredo 中继
器。如果知道，使用简单封装把分组发送出去。如果不知道，客户机格式化一个包含大随机
数（如64比特）的ICMPv6 回显报文，并经由 Teredo服务器把它发送到其IPv6 目的地。接
收主机看到一个进入的IPv6 数据报，其源地址等于客户机的Teredo地址。它产生一个回显
应答，路由到最近的Teredo中继器。然后这个中继器转发回应给客户机。接收客户机再观察
这个中继器的IPv4地址，并更新缓存以指明后续的目的地为该IPv6 主机的分组应该使用这
个刚确定下来的中继器。

在［RFC6081］中，Teredo可以支持许多扩展选项，它们中的一些有助于支持 Teredo对
对称NAT的操作。这些扩展对协议特性进行了改动，包括以下方面：对称 NAT 支持（SNS），
带 UPnP 的对称 NAT （UP），端口保留对称 NAT （PP），顺序端口对称 NAT（SP），发夹（HP），
以及服务器负载减免（SLR）。除了 UP 和PP 两个扩展都依赖于 SNS扩展以外，其他扩展都
可以独立使用。通过对这些扩展进行各种组合，多种 NAT类型都可得到支持，这些组合由
一个表格给出（见［RFC6081］的第3节）。

为了实现这些扩展，一个或多个追踪符可能会出现在Teredo消息中。使用与ICMPV6
ND选项（图8-41）一样的基本格式，追踪符被编码成一个有序的TLV组合列表，这种格
式包含一个8位的类型字段和一个8位的长度字段。类型字段的最高序的两个位编码指明
主机不能识别追踪符类型时应怎样处理。位模式01表示主机应丢弃该分组；所有其他的
都表示未知的追踪符应被忽略，而其他的则应按顺序处理。追踪符类型的值的官方列表由
IANA［TTYPES］维护。当前被定义的追踪符如表10-1所示。

表10-1

类型

0x00

Teredo追踪符被携带在封装于UDP/IPv4数据报里的IPV6负载之后。每个追踪符都有一个

类型值、名称和对应的诠释。某些情况下，长度值是一个常数

长度

名称

用途

备注

保留

未分配

未分配

0x01

0x02

0x03

0x04

保留

［8,26］

随机数（Nonce）

未分配

SNS,UP,PP,SP,HP

未分配

替换地址

HP

0x04

0x05

0x04

0×02

ND（邻居发现）选项

随机端口

SLR

PP

未分配

32位的随机数，用于防止重放攻

击（见第18章）

未分配

位于同一个NAT后面的 Teredo

客户机使用的额外的地址/端口

允许 NAT使用直接气泡（带 NS

消息）来进行更新

发送方的预测映射端口

随机数追踪符包含一个32位的随机值，该值对每个消息都是唯一的。它是一种安全措

施，防止重放攻击（见第18章），且与HP或SNS的（IPv4地址，端口）对一起使用。每个
对是6字节长，随机数追踪符可以拥有1~4个这样的对。这些对确定了一些UDPAIPV4 端
点—在一个 NAT的同一边的其他Teredo 客户机可以通过这些端点来联系发送方，同时它
们可与 HP 扩展一起使用。


ND 选项追踪符包含一个字节，用来标识 TeredoDiscoverySolicitation （0x00）或 Teredo-
DiscoveryAdvertisement（0x01）。在第一种情况下，要求接收方用一个包含第二种消息
形式的直接气泡（比如，在Teredo 客户机之间直接发送）来进行应答。TeredoDiscovery-
Advertisement类型就是应答。这个追踪符用于支持SLR 扩展，它有效地允许 NS/NA消息携
带在直接气泡里，而不是需要服务器参与的间接气泡里，以更新NAT 状态。最后，随机端
口追踪符包含一个16位的UDP端口号，这个端口号是发送方对它被映射的端口号的最好猜
测。这被PP扩展（见［RFC6081］的6.3节）使用。

\section{UDP-Lite}
有些应用程序可以容忍在发送和接收的数据里引人的比特差错。通常，为了避免建立
连接的开销或者为了使用广播或组播地址，这类应用程序会选择使用UDP，但是UDP 使
用的校验和要么覆盖整个负载，要么就一点也没有（比如，发送方不计算校验和）。一个称
为UDP-Lite 或UDPLite［RFC3828］的协议通过修改传统的UDP协议，提供了部分校验和来
解决这个问题。这些校验和只覆盖每个 UDP数据报里的一部分负载。UDP-Lite 有它自己的
IPv4 协议和IPv6 下一个头部字段值（136），因此它实际上算是一种独立的传输协议。UDP-
Lite 用一个校验和覆盖范围（Checksum Coverage） 字段取代了（冗余的）长度字段来修改
UDP 头部（见图10-8）。

0

1516

31

源端口号

（2字节）

目的端口号

（2字节）

UDP-Lite

头部

（8字节）

校验和覆盖范围

（2字节）

校验和

（2字节）

图10-8

UDP-Lite 包含了一个校验和覆盖范围字段，这个字段给出被校验和覆盖的字节数（从UDP-
Lite 头部的第1个字节开始）。最小值是0，表示整个数据报都被覆盖。值1 ~7是无效的，
因为头部总是要被覆盖的。UDP-Lite 使用一个与UDP（17）不同的IPV4协议号（136）。
IPv6在下一个头部字段中使用相同的值

图10-8中的校验和覆盖范围字段是被校验和覆盖的字节数（从 UDP-Lite 头部的第1个
字节开始）。除了特殊的值0以外，最小值是8，因为 UDP-Lite 头部自身总是要求被校验和
覆盖的。值0表示整个负载都被校验和覆盖，这就和传统UDP一样了。这里存在一个关于
IPv6 超长数据报的问题，因为用于存放校验和覆盖范围字段的空间有限。对于这类数据报，
被覆盖数最多可以是64KB 或整个数据报（即校验和覆盖范围字段的值为0）。使用一些特殊
的套接字 API 选项应用程序指明使用 UDP-Lite （IPPROTO\_UDPLITE） 和要求的校验和覆
盖范围的数量（使用 setsockopt 的 SOL\_UDPLITE、UDPLITE\_SEND\_CSCOV 和 UDPLITE\_
RECV\_CSCOV 选项）。

\section{IP分片}
正如我们在第3章介绍的，链路层通常对可传输的每个帧的最大长度有一个上限。为了
保持IP数据报抽象与链路层细节的一致和分离，IP引人了分片和重组。当IP 层接收到一个
要发送的IP 数据报时，它会判断该数据报应该从哪个本地接口发送（通过查找一个转发表，
见第5章）以及要求的MTU是多少。IP 比较外出接口的MTU 和数据的大小，如果数据报
太大则进行分片。IPv4 中的分片可以在原始发送方主机和端到端路径上的任何中间路由器上
进行。值得一提的是，数据报分片自身也可被分片。IPv6 中的分片有些不一样，它只允许源
主机进行分片。在第5章我们见过一个 IPv6 分片的例子。

当一个 IP 数据报被分片了，直到它到达最终目的地才会被重组。对此有两个原因，第
二个要比第一个重要。第一个原因，在网络中不进行重组要比重组更能减轻路由器转发软件
（或硬件）的负担。第二个原因，\emph{同一数据报的不同分片可能经由不同的路径到达相同的目的
地。如果发生这种情况，路径上的路由器通常没有能力来重组原始的数据报，因为它们都只
能看到所有分片的一个子集。}考虑到路由器当前的性能级别，表面上，第一个原因并不是很
令人信服，但是当想到大多数路由器最终无论怎样都会具备终端主机一样的功能时（如，当
它们被管理或配置时），这就更不能令人信服了。所以第二个原因仍然是主要的。

\subsection{例子：UDP /IPv4 分片}

使用UDP的应用程序如果想要避开IP 层分片，可能就得琢磨它生成的结果IP数据报
的大小了。特别是，如果结果数据报的大小超过链路的 MTU，那么IP 数据报就要被分割成
多个IP分组，这有可能导致性能问题，因为如果任何一个分片丢失了，整个数据报就丢失
了。图10-9描述了一个3023字节的 UDPAIPv4数据报被分割成多个 IPv4分组的情况。


一个带有2992字节 UDP 负载的UDP数据报被分片成三个 UDP/IPv4 分组（没有选项）。包含
源和目的端口号的UDP 头部只出现在第一个分片里（对防火墙和 NAT来说，这是一个复杂
因素）。分片由IPv4 头部中的标识（Identification）、分片偏移（Fragment Offset） 和更多分片
（More Fragments,MF）字段控制

在图 10-9 中，我们看到原始 UDP 数据报包含了2992字节的应用程序数据（UDP 负载）
和8字节的UDP头部，结果产生一个总长度（Total Length）字段值为3020字节的IPv4数
据报（回想一下，这个大小也包含了一个20字节的IPv4头部）。当这个数据报被分片成三个
分组时，产生40个额外字节（每个新生成的IPv4分片头部20字节）。因此，总发送的字节
数是3060，增加的IPv4 开销大概是1.3\%。标识字段的值（由原始发送方设置）被复制到每
个分片，同时当分片到达目的地时利用它来分成组。分片偏移字段给出该分片负载字节中的
第一个字节在原始IPv4 数据中的偏移量（以8字节为单位）。很明显，第一个分片的偏移总
是0。这里，我们看到第二个分片的偏移是185（185*8= 1480）。1480 是第一个分片的大
小减去IPv4 头部的大小。类似的分析可应用在第三个分片上。最后，MF 位字段指明该数据
报后面是否还有更多的分组，只有最后一个分片才应置成0。当MF =0的分片被接收到时，
重组程序才能确定原始数据报的长度，它等于分片偏移字段的值（乘以8）加上IPV4总长度
字段的值（减去IPv4 头部长度）。因为每个偏移字段都是相对原始数据报的，重组进程可以
处理非顺序到达的分片。当一个数据报被分片后，每个IPv4头部中的总长度字段要被修改
成该分片的总长度。

尽管 IP 分片看起来是透明的，但是一个刚才提到过的特征使得它不太理想：如果任何
一个分片丢失了，整个数据报就丢失了。要理解什么会这样，我们知道IP 自身没有差错
纠正机制。像超时和重传这些机制是更高层的责任。（TCP 有超时和重传操作，UDP 则没有。
一些基于 UDP 的应用程序自己实现超时和重传，但这在UDP 之上的某层进行。）\emph{当TCP报
文段的一个分片丢失了，TCP 会重传整个 TCP报文段，这涉及整个 IP数据报。只重发数据
报的一个分片是不可能的。}确实，如果分片由中间的路由器来做，而不是原始系统，那么原
始系统就又不知道数据报是怎样被分片的了。如此看来，通常是要避免分片的。［KM87］提
出了避免分片的一些讨论。

使用UDP，产生 IP 分片是很简单的。（后面我们将会看到 TCP尽量避免分片，一个应
用程序强迫 TCP发送比要求的分片要大得多的报文段几乎是不可能的。我们可以使用sock
程序增加数据报的大小，直到分片出现。在一个以太网里，一帧的数据最大大小一般是 1500
字节（见第3章），假设IPV4头部是20字节，UDP 头部是8字节，这就使得最大1472字
节的应用程序数据可避免分片。我们将以数据大小 1471、1472、1473及1474字节来运行
sock 程序。我们预想到最后两个会产生分片：

Linux8 sock -u -1 -n1 -w1471 10.0.0.3 discard
Linux8 sock -u -i -n1 -w1472 10.0.0.3 discard
Linux8 sock -u -1 -nl -w1473
Linux* sock -u -i -n1 -w1474 10.0.0.3 discard

清单 10-3显示了 tcpdump 输出（为了简洁，某些行已被整理）。

清单 10-3

MTU 为1500字节的以太网链路上的UDP分片

1 23:42:43.562452 10.0.0.5.46530 > 10.0.0.3.9：

udp 1471（DF）（ttl 64,id

61350,len 1499）

2 23:42:50.267424 10.0.0.5.46531> 10.0.0.3.9：

udp 1472 （DF）（tt1 64,id 62020,len 1500）

23:42:57.814555 10.0.0.5> 10.0.0.3：

udp （frag 37671:1@1480） （ttl 64,len 21）

4 23:42:57.814715 10.0.0.5.46532 > 10.0.0.3.9：

udp 1473 （frag 37671:1480@0+）（tt1 64,len 1500）

5

23:43:04.368677 10.0.0.5> 10.0.0.3：

udp （frag 37672:2@1480）

6 23:43:04.368838 10.0.0.5.46535> 10.0.0.3.9：

29932900 .6g1. 0,20m 22

udp 1474 （frag 37672:1480@0+）（tt1 64,len 1500）

前两个 UDP数据报（分组1和2）适合以太网帧（使用典型的“DIX”或“Ethernet”

封装）且没被分片。第三种情况，对应于应用程序写人的1473字节的IPv4数据报的长度是


回想一下，这个假设没有使用选项。对于带选项的IPv4数据报，头部超过20字节，最大可到60字节。

1501，这必须进行分片（分组3和4）。类似地，写人1474字节产生的数据报长度是1502字
节，同样也要分片（分组5和6）。

当捕获到一个分片数据报时，tcpdump 打印了一些附加信息。首先，输出 frag37671（分
组3和4）和 frag 37672（分组5和6）指明了IPv4头部中的标识字段。分片信息的下一个
数学（在分组4和6中的冒号和@字符之间）是IPv4分组大小，不包括IPv4 头部。两个数
据报的第一个分片都包含了1480字节的数据：8字节的UDP 头部和 1472字节的用户数据。
（20字节不带选项的IPv4 头部使得分组恰好是1500字节。）第一个被分片的数据报的第二个
分片（分组3）包含1字节的数据（用户数据剩下的1个字节）。第二个被分片的数据报的第
二个分片（分组5）包含用户数据剩下的2个字节。分片要求除了最后一个分片之外的所有
分片的数据部分（即，除IPv4 头部外的所有东西）应是8字节的倍数。本例中，1480就是8
的倍数。（相比于第5章的IPv6分片例子，那里1500字节的以太网MTU 不能被充分利用。）

跟随在@字符后的数字是指该分片的数据相对原始数据报开头的偏移量。每个新的被
分片的数据报的第一个分片都是以偏移。0开始的（分组4和6），两个数据报的第二个分片都
是从偏移 1480字节开始（分组3和5）。偏移量后的“+”字符代表还有组成这个数据报的
分片，对应IPv4头部里的3位的标志字段里的MF 位字段被置成1。

一个令人意外的现象是：\emph{有更大偏移量的分片要比第一个分片优先投递。}事实上，发
送方故意对这些分片进行了重新排序。经过思考，我们认为这样做是有好处的。\emph{如果最后一
个分片先被投递，接收主机就可以确定所需的缓存空间的最大值，以重组整个数据报。}考
虑到反正重组进程重新排序是鲁棒的，这就不是什么问题了。另一方面，有些技术要利用
更高层的信息，这些信息从第一个分片可得到（包含UDP端口号），而后面的分片都没有
［KEWG96］。

最后，注意到分组3和5（非第一个分片）遗漏了源和目的UDP端口号。tcpdump 內了
能打印除了第一个分片外的分片的端口号，它不得不重组被分片的数据报以恢复只出现在第
一个分片（该分片没有遗漏源和目的端口号）的 UDP 头部中的端口号。

\subsection{重组超时}
一个数据报的任何一个分片首先到达时，IP 层就得启动一个计时器。如果不这样做的
话，不能到达的分片（如清单 10-4中所见）可能会最终导致接收方用尽缓存，留下一种攻击
机会。清单中的例子由一个特殊程序产生，该程序构造一个ICMPv4 回显请求报文，并且以
一定延迟只发送这个消息的前面两个分片，然后不再发送任何其他分片。清单10-4显示了
回复（为了简洁，某些行已被整理）。

清单 10-4 IPv4分片重组超时

1 17:35:59.609387 10.0.0.5>10.0.0.3：

icmp:echo request （frag 28519:380eo+）（tt1 255,len 400）

2 17:36:19.617272 10.0.0.5>10.0.0.3：

icmp （frag

28519:380@376+）（tt1 255,len 400）

3 17:36:29.602373 10.0.0.3>10.0.0.5：

icmp:ip reassembly time exceeded for 10.0.0.5>10.0.0.3：

icmp:echo request （frag 28519:380@0+）（tt1 255,len 400）

［tos Oxc0］（tt1 64,id 38816,1en 424）

这里我们看到第一个分片（的时间和序列空间）被发送，总长度是400。第二个分片20s
后被发送，但最后一个分片一直没被发送。接收到第一个分片30s后，目标机器回复一个
ICMPv4 超时（代码1）消息，告诉发送方数据报已丢失，包括第一个分片的拷贝。一般的
超时时间是30s或60s。正如我们所见，收到任何一个分片时计时器就开始计时，且收到新
的分片也不会被重置。因此，计时器给出了同一数据报分片之间可被分隔的最大间隔时间的
限度。


\begin{tcolorbox}    
    历史上，大多数衍生自 Berkeley-Unix 的IP 实现方案从不产生这个错误。然
    而这些实现确实用了计时器，也确实在计时器超时的时候丢弃了所有分片，但是都
    从不产生ICMP 错误。有时会碰到另一个细节：除非接收到了第一个分片（比如分
    片偏移字段为0的分片），否则没必要产生ICMP 错误。原因是这些ICMP错误的
    接收者会因传输层头部不可用而无法知道哪个用户进程发送的数据报丢弃了。假设
    更高层协议最终将会超时，并在必要时重传它。
\end{tcolorbox}

\section{采用 UDP 的路径 MTU 发现}

让我们考察使用UDP 的应用程序与路径 MTU 发现机制（PMTUD）之间的交互过程
［RFC1191］。对一个像UDP这样的协议来说，调用这样协议的应用程序一般只控制输出数
据报的大小，如果有方法能确定一个可以避免分片的合适的数据报大小，那么这会是很有
用的。传统的PMTUD 使用ICMP PTB 消息（见第8章）来获得一个最大分组大小，其沿着
一条路由路径传输不会引人分片。典型地，这些消息在UDP层之下被处理，对应用程序不
可见，因此，它们要么是一个API 调用，被应用程序用于获取对路径（与每个路径的目的地
都已通信过）的MTU大小的当前最好的估计，要么是不被应用程序所知的、能独立地进行
PMTUD的IP层。IP层经常基于每个目的地址缓存一个 PMTUD 信息，并且当没有更新时就
让它超时。

\subsection{例子}
在下面的例子里，我们使用 sock 程序来建立一个 UDP数据报，产生一个1501字节的
IPv4数据报。无论我们的主机系统还是连接的LAN都支持一个大于1500字节的MTU，但
是路由器上到互联网的出口链路则不然。以下命令试图不间断地发送三个 UDP 消息到 echo
服务（UDP 端口为7）。

\begin{verbatim}
    Linux8 aock -u -i -n 3 -w1473 www.cs.berkeley.edu echo
\end{verbatim}

清单 10-5显示了我们在发送方使用tcpdump 看到的相应分组追踪（为了简洁，某些行已
被整理）。

清单 10-5 tcpdump 输出，显示了ICMP PTB消息。建议的MTU 包括在内

\begin{verbatim}
    
1 14:42:18.359366 IP （tos Ox0,tt1 64,id 18331, offset 0, flags ［DE］，

Proto UDP （17），length 1501）

12.46.129.28.33954 > 128.32.244.172.7: UDP,length 1473

2 14:42:18.359384 IP （tos Ox0,tt1 64,id 18332,offset O,flags ［DE］，

Proto UDP （17），length 1501）

12.46.129.28.33954 > 128.32.244.172.7: UDP,length 1473

3 14:42:18.359402 IP （tos 0x0，ttl

64,id 18333,offset O,flags ［DE］，

Proto UDP （17），length 1501）

12.46.129.28.33954

128.32.244.172.7: UDP. Lenath 1473

4 14:42:18.360156 IP （tos 0x0,tt1 255,id

23457,offset O，

flags ［none］，

Proto ICMP

（1）、length

56）

12.46.129.1> 12.46.129.28: ICMP

128.32.244.172 unreachable - need to frag （mtu 1500），length 36

IP （tos Ox0,ttl 63,id 18331,offset O,flags ［DF］，

Proto UDP （17），length 1501）

12.46.129.28.33954> 128.32.244.172.7: UDP,length 1473
\end{verbatim}

从清单10-5我们可以看到三个 UDP数据报，每个都带有1473字节的UDP（应用程
序）负载。每个都产生一个1501字节（未分片）的IPv4数据报。每个数据报的IPv4 DF 位
字段都是开启的（本系统的默认值），因此当它们中的一个到达一个路由器时（IPv4地址
12.46.129.1），就会有一条ICMPv4 PTB 消息产生，该消息包含建议的下一跳1500字节的
MTU。我们还可以观察到产生的ICMPv4消息包含了被丢弃的（“违规”）数据报的UDP/
IPv4 头部（及最前面的8个数据字节）。在这个例子里，我们的sock 程序发送它的数据报太
快（小于1ms），以至于在任何ICMP 消息被返回和处理前，它就完成了运行。

注意 现在在互联网服务提供商（ISP）中，1500字节的MTU是它们通用的最小

MTU。有些ISP引入了可支持地址分配和管理的 PPPOE，它们使用更小的1492字

节MTU。PPPOE 头部（见第3章）由6字节和随后的2字节PPP头部组成，剩下

1500-6-2=1492 字节用于封装数据报。

如果我们使用另外一台目标主机（一台我们没有路径MTU 历史的主机），同时在多次写

入之间加入额外的延迟，我们可以观察到不同的行为。使用带-P2选项的sock命令，这样
在每次发送之间加入了2秒延迟，我们使用以下的两条（相同的）命令：

Linux8 sock -u -i -n 3 -w1473 -P 2 www.wisc.edu echo

write returned -1, expected 1473: Message too 1ong

Linuxa sock -u -i -n 3 -w1473 -p 2 www.wisc.edu echo

使用另一个版本的 tcpdump，关于这些命令的tcpdump 输出由清单10-6给出（为了简

洁，某些行已被整理）。

清单 10-6 关于3000字节MTU 链路过渡到1500字节路径 MTU 的成功的路径MTU 发现示意

1 17:22:16.331023 IP （tos 0x0,tt1

64,id 58648,offset O,flags ［DE］，

Proto: UDP （17），length:1501）

12.46.129.28.33955 > 144.92.9.185.7: UDP,length 1473

2 17:22:16.331581 IP （tos 0x0,tt1 255,id 38518,offset 0，

flags ［none］，proto: ICMP（1），length:56）

12.46.129.1> 12.46.129.28: ICMP

144.92.9.185 unreachable - need to frag （mtu 1500），length 36

IP （tos Ox0，tt1

63,id 58648,offset 0, flags ［DEl，

Proto: UDP（17），length: 1501）

12.46.129.28.33955 > 144.92.9.185.7: UDP,length 1473

3 17:22:24.284866 IP （tos 0x0,tt1 64,id 53776,offset O,flags ［+］，

proto: UDP（17）、length: 1500）

12.46.129.28.33955 > 144.92.9.185.7: UDP,length 1473

4 17:22:24.284873 IP （tos 0x0,tt1 64,id 53776,offset 1480，

flags ［nonel,proto: UDP （17），length:21）

12.46.129.28

> 144.92.9.185: udp

用尸数据报协议和IP分片

351

5 17:22:26.293554 IP （tos Ox0,ttl

64,id 53777,offset 0,flags ［+］，

proto: UDP （17），length:1500）

12.46.129.28.33955 > 144.92.9.185.7:UDP,length 1473

6 17:22:26.293559 IP （tos Ox0,tt1 64,id 53777,offset 1480，

flags ［none］，Proto: UDP （17），length:21）

12.46.129.28> 144.92.9.185:udp

7 17:22:28.301469 IB （tos 0x0,tt1 64,id 53778,offset 0,flags ［+］，

proto: UDP （17），Length:1500）

12.46.129.28.33955 > 144.92.9.185.7:UDE,length 1473

8 17:22:28.301474 IP （tos 0x0,tt1 64,id 53778,offset 1480，

flags ［nonel,proto:UDP （17），length:21）

12.46.129.28> 144.92.9.185:udp

从清单10-6可以看到，第一次运行我们的程序时，由于ICMPv4 PTB 消息，程序返回

了一个错误。程序运行一次的两次发送之间的额外时间和两次程序运行之间的额外时间让

PTB 消息有机会到达发送主机，也让错误环境能传回给发送方去处理。有趣的是，当我们

第二次运行程序，路径 MTU已经被发现，为1500字节，系统能够使用分片来发送程序的

三个数据报（分组3、5、7是这三个数据报的第一个分片）。15分钟后（这里没显示），路径

MTU 信息被认为是过时的，数据报没被分片发送，另一条ICMPv4 PTB 消息被返回，以此

重复。

注薏

\iffalse
\begin{tcolorbox}
［RFC1191］推荐一个由PMTUD得到的PMTU 值在10分钟后过时。路
径MTU 发现有时会因为防火墙和网关过滤可能不加选择地丢弃ICMP 流量而
出现问题，这会损害 PMTU 发现算法。因为这点，从基于系统范畴或有更好保
证来看，可能要关闭PMTU发现。在Linux 中，文件/proc/sys/net/ipv4/ip\_no\_
Pmtu\_disc 可以置成1以关闭PMTU发现。在 Windows 中，可以编辑注册表入口
\verb|HKEY_LOCAL_MACHINE\System CurrentControl Set Services Topip Parameters
EnablePMTUDiscovery| 的值0。一个不使用ICMP 的、传统 PMTUD 的替代品已
经被开发出来［RFC4821］，我们将在第15 章介绍它。
\end{tcolorbox}
\fi

\section{IP 分片和 ARP/ND 之间的交互}

使用UDP，我们可以看到诱导的IP 分片和典型的ARP实现之间的关系。回想一下，
ARP是用于将IP 层地址映射到同一个 IPv4 子网里（见第4章）的相应的MAC层地址。我
们关心的问题包括，什么时候发送多个分片？应该产生多少条ARP消息？以及搁置中的
ARP 请求/应答在完成之前会有多少个分片要处理？（IPv6 ND 也有类似的问题。我们用以
下两条命令来查看答案，使用1500字节 MTU返回到我们的主机和 LAN：

\begin{verbatim}
    
Linux& sock -u -i -n1 -w8192 10.0.0.20 echo

Linux8 sock -u -i -n1 -w8192 10.0.0.3 echo
\end{verbatim}

这些参数使得我们的 sock 程序产生了一个带有8192字节用户数据的UDP数据报。在
一个使用1500字节 MTU大小的以太网中，我们料想到这将会产生6个分片。我们还确保了
在运行这个程序之前 ARP缓存是空的，所以在任何分片被发送之前，肯定会互相发送一个
ARP请求和应答（见清单10-7。为了简洁，某些行已被整理）。

清单 10-7

1500 字节MTU 以太网上的 ARP 和分片

1 15:45:49.063561 arp who-has 10.0.0.20 tel1 10.0.0.5

2 15:45:50.059523 arp who-has

3 15:45:51.059505 arp who-has 10.0.0.20 tel1 10.0.0.5

4 15:46:08.555725 arp who-has 10.0.0.3 tel1 10.0.0.5

5 15:46:08.555973

arp reply 10.0.0.3 is-at 0:0:c0:c2:9b:26

6 15:46:08.55599210.0.0.5>10.0.0.3：

udp （frag 27358:1480@2960+）（ttl 64,len 1500）

7 15:46:08.555998 10.0.0.5>10.0.0.3：

udp （frag 27358:1480@1480+）（tt1 64,len 1500）

8 15:46:08.556004 10.0.0.5.32808 > 10.0.0.3.7：

udp 8192 （frag 27358:1480@0+）（tt1 64,len 1500）

在这个实验里，我们正好知道地址10.0.0.20没有分配给一台运行中的主机，因此我们

应该收不到应答。在清单10-7的第一部分（分组1~3），我们观察到三个 ARP 请求被将近
1s的时间分开。三个请求被发送后，没有主机应答，因此ARP 请求者放弃了。下一种情况，
大概 250us 后有一个 ARP应答被接收到，同时大约20us后一个分片被发送。在这之后，剩
下的分片紧挨着一起被发送出去，每个之间大约有6us 的间隔。回想一下，在这个系统里
（Linux），最后一个分片首先被发送。

\begin{tcolorbox}
    历史上，分片和ARP 之间的交互一直都是有问题的。例如，在某些情况下
    每一个分片都得发送一个ARP请求，而在某些情况下只有分片中的一个要排队
    等候 ARP应答（从而使数据报丢失了，因为除了一个分片外的所有分片都被丢弃
    了）。第一个问题在［RFC1122］里被解决了，那需要一种实现来阻止这种ARP 洪
    泛。建议的最大速率是每秒一个。第二个问题也在［RFC1122］里被讨论，但它只
    指出，对每一个分组集，其中的分组的目的地是相同的未解析的IP 地址，链路层
    “应该保存（而不是丢弃）其中的至少一个（最新的）分组”’。这种方法会引起不必
    要的分组丢失，不过已经在具体实现里解决了，方法是给那些ARP请求还在挂起
    的分组提供一个更大的队列。
\end{tcolorbox}

\section{最大 UDP 数据报长度}
理论上，一个 IPv4 数据报的最大长度是65 535字节，这由IPv4 头部的16位总长度字
段决定（见第5章）。除去20字节不带选项的IPv4 头部和一个8字节的UDP 头部，就剩下
最大65 507字节留给一个 UDP 数据报的用户数据。对于IPv6，假设没使用超长数据报，16
位负载长度字段可允许655 527字节的有效 UDP 负载（65 535字节的IPv6负载中的8字节
被用于UDP头部）。然而，有两个原因使得这些大小的满额数据报不能被端到端投递。第
一，系统的本地协议实现可能有一些限制。第二，接收应用程序可能没准备好去处理这么大
的数据报。

\subsection{实现限制}
协议实现给应用程序提供一个 API 以让它选择一些默认缓存大小来进行发送和接收。某
些实现提供的默认值小于最大IP 数据报大小，实际上有些还不支持发送大于几十KB 的数据
报（尽管这个问题不多见）。

API 套接字「UNP31提供一组函数让应用程序能够调用以设置或查询接收和发送缓存的
大小。对于一个 UDP 套接字，这个大小与应用程序可读或可写的最大 UDP数据报大小直接
关联。典型的默认值是8192字节或65 535字节，但一般可以调用 setsocketopt（） API 来设置
更大的值。

在第5章我们提到过一台主机重组分片时要提供足够的缓存来接收至少一个576字节的
IPV4数据报。许多UDP应用程序被设计成限制数据报的大小在512字节或更小以下（这使
得IPv4数据报小于576字节）。对UDP数据报的大小使用了这些限制的例子包括 DNS（见
第11章）和DHCP（见第6章）。

\subsection{数据报截断}
UDP/IP 能发送和接收一个给定大小的（大）数据报并不意味着接收应用程序就能够读取
这种大小的数据报。UDP编程接口允许应用程序指定每次一个网络的读操作完成时返回的最
大字节数。如果接收的数据报超过这个指定大小会发生什么？

大多数情况下，这个问题的答案是API 截断（truncate）数据报，丢弃这个数据报里超
过接收应用程序指定字节数的任何超额数据。然而，每种实现的具体操作是不同的。一些系
统把这些数据报的超额数据放到后续的读操作中，另一些则通知调用者有多少数据被截断了
（或有些情况是通知有一些数据被截断但不知具体是多少）。

\begin{tcolorbox}    
    在Linux 中，MSG\_TRUNC 选项可被套接字API 用来查看有多少数据被截
    断。在 HP-UX上，MSG\_TRUNC 却是一个标志，当一个读操作返回“有数据被截
    断时”就进行设置。SVR4（包括 Solaris 2.x）的套接字 API 不会截断数据报。任何
    超额的数据都被返回给后续的读操作。对一个UDP数据报进行的多次读操作是不
    会通知应用程序的。
\end{tcolorbox}

在我们讨论 TCP 时会发现，它给应用程序提供连续的字节流，没有任何消息边界。因
此，应用程序可得到它请求的任意大小的数据量，可供给充足的数据（如果不行，通常可以
等待）。

\section{UDP 服务器的设计}
UDP 的一些特点对要使用它的网络应用程序的设计和实现有影响［RFC5405］。服务器一
般与操作系统交互，大多数需要一种方案来处理并发的多客户机。客户机设计与实现通常更
简单，因此我们将不在这里讨论它们。

在典型的客户机/服务端场景中，一个客户机启动，立即与一台服务器通信，然后就完
成了。而另一方面，服务器启动然后进入睡眠，等待一个客户机请求的到达。它们在客户机
数据报到达时被唤醒，这经常需要服务器来评估这个请求以及可能要进行更进一步的处理。
这里我们关注的不是客户机和服务器的程序编写方面（［UNP3］覆盖了所有这些细节），而是
对使用UDP的服务器的设计和实现有影响的UDP 协议特性。（我们检查在第13章设计的
TCP 服务器的细节。）虽然我们描述的特性有点依赖被使用的 UDP 实现，但是这些特性对大
多数实现来说是共同的。

\subsection{IP 地址和 UDP端口号}
到达 UDP 服务器的是来自客户机的UDP数据报。IP 头部包含了源和目的IP 地址，UDP
头部包含源和目的UDP端口号。当一个应用程序接收到一个 UDP 消息时，它的IP 和UDP
头部已经被剥掉；如果想要给予回复，应用程序必须由操作系统以其他方式告知是谁（源IP
地址和端口号）发送的消息。这个特点允许 UDP 服务器去处理多个客户机。

有些服务器需要知道数据报是发送给谁的，即目的IP地址。这看起来似乎很明显，服
务器不用查看接收到的数据报即可马上知道这些信息，然而通常情况并非如此。比如，因
为多址、IP 地址别名，以及 IPv6多范围使用，一台主机可能有多个IP地址，单个服务器可
使用它们中的任何一个来接收进入的数据报（实际情况通常是这样的）。任何想要根据客户
机选择的目的IP地址来有分别地执行任务的服务器都需要得到目的IP 地址信息。另外，如
果目的地址是广播或组播的（如，主机需求（Host Requirements） RFC［RFC1122］ 指出 TFTP
服务器应忽略接收到的发送给一个广播地址的数据报），那么有些服务则可能会有不同的
回应。

\begin{tcolorbox}    
DNS服务器是对目的IP地址敏感的一种服务器类型。它会使用这个信息来对
它返回的地址映射表排列特定的次序。DNS的这种行为在第11章有更详细的描述。
\end{tcolorbox}

这里得到的教训是，即使一个 API 可以得到传输层数据报里的所有数据，但是额外的来
自各层的信息（一般是地址信息）也可能是使服务器更有效地进行操作所需要的。当然，这
个问题并非 UDP 独有，然而因为它是我们第一个学习的传输层协议，现在值得提出来。

设计同时使用1Pv4和IPv6的UDP服务器必然要考虑到这两种地址类型有明显不同的
长度以及需要不同的数据结构。另外，用IPv6地址来给IPv4编码的交互操作机制可能允许
使用 IPv6 套接字同时处理IPv4和IPv6寻址。更多细节见［UNP3］。

\subsection{限制本地 IP地址}
大多数 UDP 服务器在创建UDP端点时都使其本地IP 地址具有通配符（wildcard）的特
点。也就是说如果进人的UDP数据报的目的地是一个服务器的端口，那么在该服务器上的
任何本地接口均可接收到它（任何在本地机器中使用的IP 地址，包含本地回路地址）。例如，
我们在端口号7777启动一个 IPv4 UDP 服务器：

\begin{verbatim}
    Linuxe sock -u -s 7777
\end{verbatim}

然后我们用 netstat 命令来查看端点的状态（见清单 10-8）。

清单 10-8

\begin{verbatim}
Linux& netstat -1 --udp -n
Active Internet connections（only servers）
Proto Recv-Q Send-Q Local Address    Foreign Address
udp        0      0 *:7777           0.0.0.0：*
netstat 列出了使用通配符地址绑定的IPv4 UDP 服务器
\end{verbatim}

输出中我们删除了几行，只留下我们感兴趣的。-l选项输出所有监听套接字（服务器）。
--udp 选项只输出与UDP 协议相关的数据。-n选项指明只打印IP 地址，而非全打展主机名。

\begin{tcolorbox}
    并非所有系统的 netstat 都有这些（Linux）选项，大多数是使用 netstat 命令
    加上一些选项的组合来获取类似的结果。在BSD 上，-1和-P udp 选项是被支持的。
    在 Windows 上，-n、-a和-P udp 选项都可被使用。
\end{tcolorbox}

本地地址被打印成*：7777，这里的星号代表本地IP地址已被通配符化。当服务器建立
它的端点，它可以指定主机的一个本地IP地址，包括一个广播地址，作该端点的本地IP
地址。在这些情况里，只有目的IP 地址与指定的本地地址匹配时，进人的UDP数据报才会
被转到这个端点。使用我们的sock 程序，如果我们在端口号前指定一个IP地址，它就成为
了这个端点的本地地址。例如，命令

Linux8 sock -u -s 127.0.0.1 7777

限制了服务器只接收到达本地回路接口（127.0.0.1）的数据报，这些数据报只能在同一台主
机生成。清单 10-9显示了本例的 netstat 输出。

\begin{verbatim}
    Linux& netstat -1 --udp -n
    Active Internet connections（only servers）
    Proto Recv-Q Send-Q Local Address    Foreign Address
    udp        0      0 127.0.0.1:7777   0.0.0.0：*
    netstat 列出了使用通配符地址绑定的IPv4 UDP 服务器
\end{verbatim}
清单 10-9 只绑定本地回路接口的 UDP IPv4 服务器 netstat 输出

如果我们尝试在同一以太网的主机上发送一个数据报到这个服务器，一个 ICMPv4 端口
不可到达消息就会被返回，发送应用程序会接收到一个错误。服务器看不到这个数据报。

\begin{verbatim}
    Linux%  sock -u -v 10.0.0.3 6666
    connected on
    error: Connection refused
\end{verbatim}

\subsection{使用多地址}
在同一个端口号开启几个不同的服务器，每个服务器使用一个不同的本地IP地址，这

是可能的。然而，通常应用程序应该告诉系统允许这样重用相同的端口。


\begin{tcolorbox}
使用套接字API时，\verb|SO_REUSEADDR| 套接字选项必须指定。在我们的
sock 程序里通过指明-A 选项即可。
\end{tcolorbox}

即使我们只有一个真实的网络接口，我们还是可以建立额外的IP 地址来供使用。这里，
我们的主机有一个原生IPv4 地址 10.0.0.30，而我们将赋予它两个额外的地址：

\begin{verbatim}
    Linux# ip addr add 10.0.2.13
    scope host dev ethO
    Linux# ip addr add 10.0.2.14 scope host dev etho
\end{verbatim}

现在我们的主机有4个单播IPv4地址：它的原生地址，我们刚才加的那两个，以及它
的本地回路地址。我们可以使用sock程序在同一个 UDP端口（8888）开启三个不同的UDP
实例：

\begin{verbatim}
    
Linux& sock

-U-$ -A

Linux8

sock

-U-8-A

8888

8888

Linux8

sock -u -8 -A 8888
\end{verbatim}

服务器必须使用-A选项来启动，告诉系统允许重用相同的地址信息。清单10-10的
netstat 输出显示了服务器正在监听的地址和端口号。

清单10-10 相同UDP端口上的受限的和带通配符的UDP服务器

Active Internet

connections （only servers）

Proto Recv-Q

Local Address

udp

udp

0

0

0

0

0.0.0.0:8888

Foreign Address

0.0.0.0：*

0.0.0.0：*

0.0.0.0：*

在这个场景里，只有那些目的地是10.0.0.30、直接广播地址（如，10.255.255.255）、受
限广播地址（255.255.255.255）或本地回路地址（127.0.0.1）的IPv4 数据报才能到达带通配
符本地地址的那个服务器，因为那些受限的服务器覆盖了所有其他的可能情况。

当有带通配符地址的端点存在时，就暗示着一种优先级。\emph{带指定 IP 地址的端点，会越
过通配符，当这个指定的 IP 与目的 IP 地址匹配时，它总是被优先选择}。而只有当匹配不成
功时才会使用带通配符的端点。

\subsection{限制远端IP地址}
在前面我们展示的所有 netstat 输出中，远端IP 地址（比如，不是正在运行的服务器本
地的地址）和远端端口号被显示 0.0.0.0：*，表示端点将会接收来自任何IPv4地址和任何
端口号的进人UDP数据报。\emph{然而，可以选择限制远端地址，也就是说端点只接收来自指定
IPv4地址和端口号的 UDP 数据报。}注意，一旦服务器收到了某个客户机的流量，这些限制
就会被加上，以过滤掉来自其他客户机的额外流量。在我们的 sock 程序中使用-f选项来指
定远端IPv4 地址和端口号：

Linux8 sock -u -8 -f 10.0.0.14.4444 5555

这样就设置了远端IPv4地址为10.0.0.14以及远端端口号4444。服务器端口
5555。如果运行 netstat，我们可以看到本地地址也被设置，尽管我们没有明确指定它（见
清单10-11）。

清单 10-11

限制远端地址导致的本地地址分配

\begin{verbatim}
    
Linux& netstat

--udp -n

Active Internet connections （w/o servers）

Proto Recv-O Send-0 Local Address

Foreign Address

udp

0

010.0.0.30:5555 10.0.0.14:4444

State

ESTABLISHED
\end{verbatim}

这是指定远端IP 地址和远端端口的一个典型的副作用：如果指定远端地址而没选择本

地地址的话，那么本地地址会被自动选择。它的值是由IP路由选择的能到达那个指定的远
端IP地址的网络接口的地址。确实，在这个例子里，在这个以太网里能连接到那个远端地
址的主要IPv4地址就是10.0.0.30。注意这样得到的端点和限制远端地址的一个结果是，现
在清单里的状态（State）栏指示连接是已建立的（ESTABLISHED）。

表10-2总结了 UDP服务器可建立的三种地址绑定方式。

本地地址

local\_IP.local\_port

local\_IP.local\_port

*.local\_port

表10-2 UPD 服务器的三种地址绑定方式

远端地址

foreign\_IP.foreign\_port

**（wildcard）

**（wildcard）

描

述

限制只有一台客户机可用

限制本地 IP 地址和端口（但对所有客户机开放）

只限制本地端口

在所有情况里，local\_port 是服务器的端口，local\_IP 必须是本地分配的IP 地址中的一

个。表中三行的顺序就是 UDP 模块在尝试决定哪个本地端点去接收进人数据报时使用的顺
序。最具体的绑定方式（第一行）首先被尝试，最不具体的（最后一行，两个IP地址都是通
配符）被最后尝试。

用户数据报协议和 IP分片

357

\subsection{每端口多服务器的使用}
尽管RFC里没有说明，但默认情况下最常见的是：对一给定的地址族（即IPV4或

IPv6），同一时间只允许一个应用程序端点与任何一个（本地IP 地址，UDP 端口号）对关联。
当一个 UDP数据报到达其目的IP 地址的那台主机的目的活动端口时，它的一个拷贝被传送
给这个唯一的端点（如，一个正在监听的应用程序）。如前所示，这个端点的IP 地址可以是
通配符，但是只能是唯一一个应用程序可以接收这些指定地址的数据报。如果我们试图去启
动另一个使用相同地址族、有相同通配符本地地址和相同端口的服务器时，则是行不通的：

\begin{verbatim}
    
Linux& sock -u -8 12.46.129.3

8888 &

Linux8 sock -u -s 12.46.129.3 8888

can't bind local address: Address already in use
\end{verbatim}

为了支持组播（见第9章），可允许多个端点使用相同的（本地IP 址，UDP端口号）对，

但是应用程序一般要告诉API 允许这样做（也就是说，像前面指出的，用-A选项来指定
，\_REUSEADDR 套接字选项）。

注意 4.4BSD 要求应用程序设置不同的套接字选项（SO\_REUSEPORT）来允许多端点

共享同一端口。此外，每个端点必须设置这个选项，包括第一个使用这个端口的端点。

当一个 UDP数据报到达的目的IP地址是一个广播或组播地址，同时这个目的IP地址

和端口号有多个端点时，那么每个端点都会收到这个数据报的一个拷贝（端点的本地IP地址
可以是能匹配任何目的IP地址的通配符）。然而，如果一个 UDP数据报到达其目的IP地址
是一个单播地址（即一个普通的地址）时，那么只有唯一的端点会收到这个数据报的一个拷
贝。至于哪个端点会收到这个单播数据报，这是依赖于具体实现的，但是这种策略有助于允
许多线程和多进程服务器避免在同一进入请求上被多次调用。

\section{跨越地址族：IPv4 和 IPv6}

编写不只跨越协议（例如 TCP 和 UDP）而且跨越地址族的服务器是可能的。即，我们可
以编写服务器，既可对IPv4 也可对IPv6 的进入请求进行回复。这整个看起来好像是简单明
了的（IPv6地址只是同一主机上的128位长的IP地址而已），但是关于共享端口空间会有些
小问题。对于某些系统，UDP（和TCP）的IPv6和IPv4之间的端口空间是共享的。这就是
说如果一个服务绑定在一个使用IPv4的UDP 端口上，它同时也被分配给在IPv6 空间里的
同一个端口（反之亦然），使得其他服务不能使用该端口（除非如前所述，SO\_KEUSEADDR

套接字选项被使用）。更进一步，因为IPv6地址能以一种互操作的方式（见第2章）来对
IPv4 地址进行编码，所以IPv6里的通配符绑定方式可能会接收到进入的IPv4流量。

注意 情況要针对具体实现。在Linux 里，所有端口空间都是共享的，所有的通配
符 IPv6绑定意味着对应的IPv4绑定。在 FreeBSD 里，IPV6\_V6ONLY 套接字选
项可用于保证只在 IPv6 空间进行绑定。程序员应该查阅其支持的那个操作环境的
IPV6的套接字接口。［RFC3493］ 描述了C语言绑定。

\section{流量和拥塞控制的缺失}

大多数UDP 服务器是迭代（iterative）服务器。也就是说单个服务器线程（或进程）在
单个UDP端口（如，服务器的知名端口）处理所有客户请求。通常一个应用程序使用的每
个 UDP端口均有一个大小有限的队列与之对应。也就是说来自不同客户机的、几乎同时到
达的请求会被UDP 自动排入队列里。接收到的UDP 数据报以它们到达的顺序（也就是说，
FCFS——先到先服务）被传送给应用程序（当它请求下一个时）。

然而，这个队列有可能会溢出，使得 UDP 实现丢弃进入的数据报。因为 UDP 不提供流
量控制（Hlow control）（也就是说，让服务器告诉客户机减慢速率是不可能的），即使只服务于
一个客户，这样的事情也会发生。因为 UDP 是一个无连接协议，自身没有可靠机制，应用
程序无法得知什么时候 UDP 输入队列产生了溢出。超额的数据报仅仅被 UDP 丢弃而已。

这样的事实引起了另一个问题，发送方和接收方之间的IP 路由器（在网络中间）里也有
队列。当这些队列变满时，流量可能会被丢弃，多多少少与UDP 的输入队列类似。当这种
情况出现时，网络被称之为拥塞（congested）。拥塞是不希望的，因为它会影响所有流量经
过拥塞发生地点的网络用户，这与前面提到的UDP 输入情况不一样，那里只有单个应用程
序服务受影响。UDP 对拥塞提出了特别的关注，因为当网络正在拥塞时，不能通知它降低发
送率。（即使能被告知，也没有机制来降低。）因此，这被称次拥塞控制（congestion control）
缺失。拥塞控制是一个复杂的课题，目前仍是一个热门研究领域。我们在讨论 TCP 时（见第
16章）将会考虑拥塞控制。

\section{UDP/IPv4 和 UDP/IPV6 数据报的转换}
在第7章我们讨论了一个用于从 IPv4 传送IP 数据报到IPv6（或反之）的框架。第8章
描述了这个框架如何应用到ICMP。像第7章描述的那样，当UDP 经过一个转换器时，转
换就会发生，除了针对UDP校验和的一些问题。对于 UDP/IPv4数据报，UDP 头部的校
验和字段允许为0（不计算），而UDP/IPv6则不然。后果是，校验和为0的完整数据报到
来时，从IPv4转换到IPv6产生的结果是，生成一个带有完整进行了计算的伪头部校验和
的UDP/IPv6 数据报，或者是丢弃了到来的数据报。转换器应提供一个配置选项来选择取舍
哪种情况，因为产生这些校验和的开销可能是不能接受的。如果使用了非校验和中立（non-
checksum-neutral）的地址映射的话（见第7章），包含非零校验和的分组在任一边被转换时都
要求更新校验和。

分片数据报出现另一个挑战。对于无状态的转换器，被分片的带有零校验和的 UDP/IPV4
数据报不能转换，因为没有合适的UDP/IPv6可以计算。这些数据报被丢弃。有状态的转换器
（即NAT64）可以重组许多分片和计算要求的校验和。被分片的带有已计算校验和的UDP/IP
数据报在转换的两边都被当作普通分片处理，如第7章所述。大UDP/IPv4 数据报需要分片以
适合转换后的IPv6最小MTU，它们同样被当作普通IPv4 数据报处理（即它们按需求分片）。

\section{互联网中的 UDP}
如果试图描述互联网上的UDP 流量的特征，我们会发现，要得到有用、公众可用的数
据是有些困难的，同时各个站点因协议引起的流量负载的崩溃也不尽一样。也就是说，像
［FKMC03］这样的研究发现，UDP 占据了观察到的互联网流量的10\% ~40\%，同时随着点
对点应用数量的增加，UDP 的使用也正在上升［Z09］，尽管 TCP 流量仍在分组和字节量方面
占据了统治地位。

在［SMC02］中，发现互联网分片流量大多数都是UDP的（分片流量的68.3\%是UDP
的），尽管总体流量中只有极少是分片的（大约分组的0.3\%，字节的0.8\%）。该作者指出最
常见的被分片的流量类型是基于 UDP 的多媒体流量（55\%；微软的媒体播放器占了其中的
一半），以及像出现在VPN隧道里的封装/隧道流量（大约22\%）。此外，大约10\%的这些
分片是反序的（reverse-order）（我们在之前的例子里说过最后一个IP 分片要优先第一个被发
送），最常见的分片大小是1500字节（75\%），然后是1484字节（18\%）和1492字节（1\%）。
注意1500字节MTU 与以太网的原生可用负载大小有关。大小1484是由数字设
备公司（Digital Equipment Corporation）的GigaSwitch（现在已不存在）产生的，
它在当时是拓扑测量的重要部分。

分片出现的原因来自两个因素：粗糙封装和路径 MTU 发现的缺失，以及采用可能使用
大消息的应用程序。前者与经过多个协议层时的多层封装有关，这增加了额外的头部，使
得原始适合1500字节MTU（最常见的大小）的IP 分组不再装得下（如，要经过VPN隧道
的应用程序流量）。第二个因素在于使用大分组的应用程序（如视频应用程序）最终要分片。
［SMC02］研究里的一个奇怪和不幸的发现是，大量的IPv4 DF 位字段是启用的UDP 分组
（可能要尝试进行 PMTU发现）被封装在没启用该位字段的UDP 分组里（从而破坏了该尝试，
却使相应的应用程序对此事实一无所知）。

\section{与 UDP 和 IP 分片相关的攻击}
大多数关于 UDP的攻击与耗尽某些共享资源（缓存，链路容量等）或利用协议实现中的
漏洞以致系统崩溃或产生其他不希望的反应有关。两者都属于 DoS攻击这个大分类：成功的
攻击者可使服务对合法用户不可用。最直接的使用UDP 的DoS攻击是尽可能快地直接产生
大量的流量。因为UDP 不能管理它的流量发送率，这对与之共享相同网络路径的其他应用
程序产生负面的影响。甚至在没有恶意的情况下，这也可能发生。

经常与UDP相关的另一种更复杂的Dos攻击类型是放大（magnification）攻击。这种
攻击类型通常涉及一个攻击者发送小部分流量，而致使其他系统产生更多的流量的情况。在
所谓的 Fraggle 攻击中，一个恶意的UDP 发送方伪造IP 源地址成一个受害者的地址，并且
设置目的地址为广播类型的一种（如，直接广播地址）。UDP 分组被发送到一个能对进入数
据报做回应的服务。实现了这些服务的服务器在回应时，它们把消息导向到包含在到达的
UDP 分组的源IP地址字段里的IP 地址。这样，源地址就是那个受害者，所以受害者主机就
会因有多个 UDP 流量对其回应而处于超负载中。这种放大攻击的变种有很多，包括诱导一
个字符生成服务与回显服务交互，从而使得流量一直处于“乒乓”中。这种攻击与ICMP的
Smurf 攻击（见第8章）很接近。

出现过几种与IP分片有关的攻击。处理IP 分片要比处理UDP 更加复杂一些，因此在
它的实现中发现并利用漏洞不足为奇。有一种攻击方式涉及发送不带任何数据的分片。这种
攻击利用IPv4重组程序代码的一个漏洞，可导致系统崩溃。另一种在IPv4 重组层的攻击是
泪滴（teardrop）攻击，涉及使用可使某些系统崩溃或严重受影响的重叠分片偏移（Fragment
Offset）字段来精心构造一系列分片。这种攻击的一个变种涉及可覆盖前一分片 UDP头部
的重叠分片偏移。现在，重叠分片在 IPv6 中被禁止使用［RFC5722］。最后，还有与之相关
的Ping of Death 攻击（一般由ICMPv4 回显请求构建，也适合于 UDP），它通过产生一个在
重组时会超过最大限制的IPv4数据报来进行。这是相当直接的，因分片偏移字段可设置
的值最大只能到8191，代表了65 528字节的偏移。任何长度超过7字节的这样的分片都会
（如果没有保护措施）导致产生一个超过最大值65 535字节的重组数据报。关于某些形式的
分片攻击的应对技术在［RFC3128］给出。

\section{总结}
UDP是一个简单的协议。它的正式规范［RFC0768］ 只有3页（包括参考文献！）。它给
用户进程（在IP 层之上）提供的服务是端口号和校验和。它没有流量控制，没有拥塞控制和
差错纠正。它有差错检测（对 UDP/IPv4 可选，但对UDP/IPv6强制使用）和消息边界保留。
我们使用了 UDP 来检查互联网校验和以及观察IP 分片如何进行。我们也见到了UDP 的其
他方面：它如何与路径 MTU发现一起使用，如何影响服务器设计，以及它在互联网的出现。
当要避免建立连接的开销时，当要使用多端点传送时（组播，广播），或者当不需要TCP

的相对“笨重”的可靠语义（例如排序、流量控制以及重传）时，最常用的就是UDP了。多
亏了多媒体和点对点应用程序，UDP 正得到越来越多的使用，同时它也是支持VoIP 的主要
协议［RFC3550］［RFC3261］。它还是那些要必须经过 NAT 而不引入太多额外开销（只为 UDP
头部提供8字节）的封装流量的传统方法。在支持一种 IPv6过渡机制（Teredo）和帮助 NAT
穿越STUN（见第7章）方面，我们已经看到了这种用法，同时我们将会在第18章再次看到
它被用于 IPsec NAT 穿越。UDP 其他主要用途之一是支持DNS。下一步我们在第11 章就探
讨这种重要的应用。

\section{参考文献}
［CT90］ D. Clark and D. Tennenhouse， "Architectural Considerations for a New
Generation of Protocols，” Proc. ACM SIGCOMM, 1990.

［FKMC03］ M. Fomenkov, K. Keys, D. Moore, and k claffy， "Longitudinal Study of
Internet Traffic in 1998-2003，" CAIDA Report, available from http://www.caida.
org,2003.

［IPORT］ http://www.iana.org/assignments/port-numbers

［KB929851］ Microsoft Support Article ID 929851， "The Default Dynamic Port
Range for TCP/IP Has Changed in Windows Vista and in Windows Server 2008，"
Nov. 19, 2009 （rev. 6.2）.

［KEWG96］ F. Kaashoek, D. Engler, D. Wallach, and G. Ganger， "Server Operating
Systems，" Proc. SIGOPS European Workshop, 1996.

［KM87］ C. Kent and J.Mogul，"Fragmentation Considered Harmful” DEC WRL
Technical Report 87/3, 1987.

［RFC0768］ J. Postel， "User Datagram Protocol" Internet RFC 0768/STD 0006, Aug.
1980.

［RFC1122］ R. Braden, ed.， "Requirements for Internet Hosts—Communication
Layers/" Internet RFC 1122/STD 0003, Oct. 1989.

［RFC1191］ J. C. Mogul and S. E. Deering， "Path MTU Discovery" Internet RFC
1191, Nov. 1990.

［RFC2460］ S. Deering and R. Hinden， "Internet Protocol, Version 6 （IPv6） Specifi-
cation，" Internet RFC 2460, Dec. 1998.

IRFC2675］ D. Borman, S. Deering, and R. Hinden， "1Pv6 Jumbograms" Internet
RFC 2675, Aug. 1999.

［RFC30561 B. Carpenter and K. Moore， " Connection of IPv6 Domains via IPv4
户数据报协议和IP分片

Clouds，" Internet RFC 3056, Feb. 2001.

［RFC3128］ I. Miller， "Protection against a Variant of the Tiny Fragment Attack
（RFC 1858）" Internet RFC 3128 （informational）， June 2001.

［RFC3261］J. Rosenberg, H. Schulzrinne, G. Camarillo, A. Johnston, J. Peterson，
Sparks, M. Handley, and E. Schooler， “SIP: Session Initiation Protocol，” Interne
RFC 3261, June 2002.

［RFC3493］ R. Gilligan, S. Thomson, J. Bound, J. McCann, and W.Stevens， "Basi
Socket Interface Extensions for IPv6" Internet RFC 3493 （informational）， Feb.
2003.

［RFC3550］ H. Schulzrinne, S. Casner, R. Frederick, and V.Jacobson， "RTP: A
Transport Protocol for Real-Time Applications/" Internet RFC 3550/STD 0064，
July 2003.

［RFC3828］ L-A. Larzon, M. Degermark, S. Pink, L-E. Jonsson, ed.， and G.
Fairhurst, ed， "The Lightweight User Datagram Protocol （UDP-Lite）" Internet
RFC 3828, July 2004.

［RFC4213］ E. Nordmark and R. Gilligan， "Basic Transition Mechanisms for IPv
Hosts and Routers，" Internet RFC 4213, Oct. 2005.

［RFC4380］ C. Huitema， "Teredo: Tunneling IPv6 over UDP through Network
Address Translations （NATs）" Internet RFC 4380, Feb. 2006.

［RFC4787］ F. Audet, ed.， and C. Jennings， "Network Address Translation （NAT
Behavioral Requirements for Unicast UDP" Internet RFC 4787/BCP 0127, Jan.
2007.

［RFC4821］ M. Mathis and J. Heffner， "Packetization Layer Path MTU Discovery
Internet RFC 4821,Mar. 2007.

［RFC4960］ R. Stewart, ed.， "Stream Control Transmission Protocol" Internet RI
4960, Sept. 2007.

［RFC5405］ L. Eggert and G. Fairhurst， "Unicast UDP Usage Guidelines for
Application Designers” Internet RFC 5405/BCP 0145, Nov. 2008.

［RFC5722］ S. Krishnan， "Handling of Overlapping IPv6 Fragments" Internet
RFC 5722, Dec. 2009.

［RFC5969］ W. Townsley and O. Troan， "IPv6 Rapid Deployment on IPv4 Infra-
structures （6rd）—Protocol Specification，" Internet RFC 5969, Aug. 2010.

［RFC5991］ D. Thaler, S. Krishnan, and J. Hoagland， "Teredo Security Updates，"
Internet RFC 5991, Sept. 2010.

［RFC6081］ D. Thaler， "Teredo Extensions,/" Internet RFC 6081, Jan. 2011.

［RFC6343］ B. Carpenter， "Advisory Guidelines for 6to4 Deployment" Internet
RFC 6343 （informational）， Aug. 2011.

［SMC02］ C. Shannon, D.Moore, and k claffy， "Beyond Folklore: Observations C
Fragmented Traffic" IEEE/ACM Transactions on Networking, 10（6）， Dec. 2002.

［SOCK］ http://www.icir.org/christian/sock.html

［TTYPES］ http://www.iana.org/assignments/trailer-types

IUNP3］ W. Stevens, B. Fenner, and A. Rudoff, LNIX Network Programming, Volw
1, Third Edition （Addison-Wesley, 2004）.

［Z09］ M. Zhang et al.， "Analysis of UDP Traffic Usage on Internet Backbone
Links"Proc.9th Annual International Sumposium on Applications and the Internet
TCPAP Ilustrated, Volume l: The Protocols, Second Edition
