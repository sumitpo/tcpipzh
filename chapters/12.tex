\chapter{TCP: 传输控制协议}

\section{引言}
到目前为止，我们一直在讨论那些自身不包含可靠传递数据机制的协议。它们可能会使用一种想校验和或\verb|CRC|这样的数学函数来\emph{检测}接收到的有差错的数据，但是
它们不尝试去纠正差错。对于\verb|IP|和\verb|UDP|，根本没有差错纠正。对于以太网和基于其上的其他协议，协议提供一定次数的重试，如果还是不成功则放弃。

通信媒介可能会丢失或改变所传递的消息，在这种环境下的通信问题已经被研究了多年。关于这个课题的一些最重要的理论工作由克劳德·香农在1948年给出。
这些工作普及了术语“比特”，并成为\emph{信息理论}(information theory)领域的基础，帮助我们理解了在一个\emph{有损}（可能删除或改变比特）信道里可通过的信息量的根本限制。
信息理论与\emph{编码理论}(coding theory)的领域密切相关，编码理论提供不同的信息编码手段，从而使得信息能够在通信信道里尽量免于出错。使用\emph{差错校正码}(基本上是添加
一些冗余的比特，使得即使某些比特被毁，真实的信息也可以被恢复过来)来纠正通信问题是处理差错的一种非常重要的方法。另一种方法是简单地“尝试重新发送”，直到消息
最终被接收。这种方法，被称为\emph{自动重复请求} (\verb|Automatic Repeat Request, ARQ|)，构成了许多通信协议的基础，包括\verb|TC|P在内。
\subsection{ARQ和重传}
如果我们考虑的不只是单个通信信道，而是几个的多跳级联，我们会发现不只会碰到前面提到的那几种差错类型（分组比特差错），而且还会有更多其他的类型。这些问题可能发生
在中间路由器上，是几种在讨论IP 时会遇到的问题：分组重新排序，分组复制，分组泯灭（丢失）。为在多眺通信信道（例如IP）上使用而设计的带纠错的协议必须要处理这些问题。
现在让我们来探讨能处理这些问题的协议机制。在概括性地讨论这些之后，我们会探究它们是如何被\emph{TCP}在互联网上使用的。

一个直接处理分组丢失（和比特差错）的方法是重发分组直到它被正确接收。这需要一种方法来判断：（1）接收方是否已收到分组；（2）接收方接收到的分组是否与之前发送方
发送的一样。接收方给发送方发信号以确定自己已经接收到一个分组，这种方法称为\emph{确认}（\verb|acknowledgment|），或\verb|ACK|。最基本的形式是，发送方发送一个分组，然后等待一个\verb|ACK|。
当接收方接收到这个分组时，它发送对应的\verb|ACK|。当发送方接收到这个\verb|ACK|，它再发送另一个分组，这个过程就这样继续。这里会有一些有意思的问题：（1）发送方对一个\verb|ACK|应
该等待多长时间？（2）如果 \verb|ACK| 丢失了怎么办？（3）如果分组被接收到了，但是里面有错怎么办？

正如我们将看到的，第一个问题其实挺深奥的。决定去等待多长时间与发送方期待（expect）为一个ACK 等待多长时间有关。现在确定这个时间可能比较困难，因此我们推迟
对这个技术的讨论，直到我们在后面（见\autoref{chap:tcp_timeout_retrans}）详细讨论\verb|TCP|。第二个问题的答案比较容易：如果一个\verb|ACK|丢失了，发送方不能轻易地把这种情况与原分组丢失的情况区分开来，
所以它简单地再次发送原分组。当然，这样的话，接收方可能会接收到两个或更多的拷贝，因此它必须准备好处理这种情况（见下一段）。至于第三个问题，我们可以借助在12.1节中
提到的编码技术来解决。使用编码来检测一个大的分组中的差错（有很大的概率）一般都很简单，仅使用比其自身小很多的一些比特即可纠正。更简单的编码一般不能纠正差错，但是
能检测它们。这就是校验和与CRC会如此受欢迎的原因。然后，为了检测分组里的差错，我们使用一种校验和形式。当一个接收方接收到一个含有差错的分组时，它不发送\verb|ACK|。
最后，发送方重发完整到达的无差错的分组。

到目前为止即使这种简单的场景，接收方都可能接收到被传送分组的重复（\verb|duplicate|）副本。这个问题要使用序列号（\verb|sequence number|）来处理。基本上，在被源端发送时，每个
唯一的分组都有一个新的序列号，这个序列号由分组自身一直携带着。接收方可以使用这个序列号来判断它是否已经见过这个分组，如果见过则丢弃它。

到目前为止介绍的协议是可靠的，但效率不太高。如果从发送方到接收方传递即使一个很小的分组都要用很长时间（推迟或延迟）的话（如一秒或两秒，对卫星链路来说并非不正
常），考虑一下那会怎样。发送方可以注入一个分组到通信路径，然后停下来等待直到它收到ACK。这个协议因此被称为“停止和等待”。假设没有分组在传输中丢失和无可挽回地损
害，该协议的吞吐量性能（每单位时间发送在网络中的数据量）与$M/R$ 成正比，$M$是分组大小，$R$是往返时间（\verb|RTT|）。如果有分组丢失和损害的话，情况甚至更糟糕：“吞吐质”（每单
位时间传送的有用数据量）明显要比吞吐量要低。

对于不会损害和丢失太多分组的网络来说，低吞吐量的原因是网络经常没有处于繁忙状态。情况与使用装配流水线时不出一个完整产品就不准新的工作进入类似。流水线大部分
时间是空闲的。我们进一步对比，很明显，如果我们允许同一时间有多个工作单元进入流水线，就可以做得更好。对网络通信来说也是一样的——如果我们允许多个分组进人网络，就
可以使它“更繁忙”，从而得到更高的吞吐量。

很明显，允许多个分组同时进人网络使事情变得复杂。现在发送方必须不仅要决定什么时间注人一个分组到网络中，还要考虑注人多少个。并且必须要指出在等待ACK 时，怎样
维持计时器，同时还必须要保存每个还没确认的分组的一个副本以防需要重传。接收方需要有一个更复杂的ACK机制：可以区分哪些分组已经收到，哪些还没有。接收方可能需要一
个更复杂的缓存（分组保存）机制——允许维护“次序杂乱”的分组（那些比预想要先到的分组更早到达的分组，因为丢包和次序重排的原因），除非简单地抛弃这些分组，而这样做
是很没效率的。还有其他一些没有这么明显的问题。如果接收方的接收速率比发送方的发送速率要慢怎么办？如果发送方简单地以很高的速率发送很多分组，接收方可能会因处理或内
存的限制而丢撑这些分组。中间的路由器也会有相同的问题。如果网络基础设施处理不了发送方和接收方想要使用的数据发送率怎么办？
\subsection{分组窗口和滑动窗口}
为了解决所有这些问题，我们以假设每个分组有一个序列号开始，正如前面所描述的。我们定义一个分组窗口（window）作为已被发送方注入但还没完成确认（如，发送方还从没收
到过它们的ACK）的分组（或者它们的序列号）的集合。我们把这个窗口中的分组数量称为有口大小（window size）。术语窗口来自这样的想法：如果你把在一个通信对话中发送的所有
分组排成长长的一行，但只能通过一个小孔来观察它们，你就只能看到它们的一个子集--像通过一个窗口观看一样。发送方的窗口（以及其他分组队列）可画图描述成12-1那样。

发送方窗口，显示了哪些分组将要被发送（或已经发送），哪些尚来发送，以及哪些已经发送并确认。在这个例子里，窗口大小被确定三个分组

这个图显示了当前三个分组的窗口，整个窗口大小是3。3号分组已经被发送和确认，所以由发送方保存的它的副本可以被释放。分组7在发送方已经准备好，但还没被发送，因
为它还没“进入”窗口。现在如果我们想象数据开始从发送方流到接收方，ACK 开始以相反的方向流动，发送方可能下一步就接收到一个分组4的ACK。当这发生时，窗口向右边“滑
动”一个分组，意味着分组4的副本可以释放了，而分组7可以被发送了。窗口的这种滑动给这种类型的协议增加了一个名字，滑动窗口 （sliding window）协议。

这种滑动窗口方法可用于对付到目前为止描述过的许多问题。一般来说，这个窗口结构在发送方和接收方都会有。在发送方，它记录着哪些分组可被释放，哪些分组正在等待
ACK，以及哪些分组还不能被发送。在接收方，它记录着哪些分组已经被接收和确认，雪些分组是下一步期望的（和已经分配多少内存来保存它们），以及哪些分组即使被接收也将会因
内存限制而被丢弃。尽管窗口结构便于记录在发送方和接收方之间流动的数据，但是关于窗口应多大，或者如果接收方或者网络处理不过来发送方的数据率时会发生什么，它都没有提
供指导建议。现在我们应该看看这些怎样关联在一起。


\subsection{变量窗口：流量控制和拥塞控制}
为了处理当接收方相对发送方太慢时产生的问题，我们介绍一种方法，在接收方跟不上时会强迫发送方慢下来。这称为流量控制（flow control），该控制经常以下述两种方式之一来
进行操作。一种方式称为基于选率（rate-based）流量控制，它是给发送方指定某个速率，同时确保数据永远不能超过这个速率发送。这种类型的流量控制最适合流应用程序，可被用于
广播和组播发现（见第9章）。

另一种流量控制的主要形式叫基子窗口（window-based）流量控制，是使用滑动窗口时最流行的方法。在这种方法里，窗口大小不是固定的，而是允许随时间而变动的。为了使用
这种技术进行流量轻制，必须有一种方法让接收方可以通知发送方使用多大的窗口。这一般称为窗口通告（window advertisement），或筒单地称为窗口更新（window update）。发送方
（即窗口通告的接收者）使用该值调整其窗口大小。逻辑上讲，一个窗口更新是与我们前面讨论过的ACK 分离的，但是实际上窗口更新和 ACK 是由同一个分组携带的，意味着发送方往
往会在它的窗口滑动到右边的同时调整它的大小。

如果我们考虑到在发送方修改窗口大小会带来的影响，就可以很明显地知道这是怎样达到流量控制的。在没收到它们中任何一个的ACK之前，发送方允许注入 W个分组到网络
中。如果发送方和接收方足够快，网络中设有丢失一个分组以及有无穷的空间的话，这意味粉通信速率正比于（SW/R）b/S，这里W 是窗口大小，§是分组大小（按比特算），R是往返时
间（RTT）。当来自接收方的窗口通告夹带着发送方的位 W时，那么发送方的全部速率就被限制而不能超越接收方。这种方法可以很好地保护接收方，但是对于中间的网络呢？在发送
方和接收方之间可能会有有限内存的路由器，它们与低速网络链路抗争着。当这种情况出现时，发送方的速率可能超过某个路由器的能力，从而导致丢包。这由一种特殊的称为拥塞控
制（congestion control）的流量控制形式来处理。

拥塞控制涉及发送方减低速度以不至于压垮其与接收方之间的网络。回想我们关于流量控制的讨论，我们使用一个窗口通告来告之发送方为接收方减慢速度。这称为明确（explicit）
发信，因为有一个协议字段专用于通知发送方正在发生什么。另一个选项可能被发送方用于猜测（guess）它需要慢下来。这种方法涉及隐性（implicit）发信—一涉及根据其他某些证据
来决定减慢速度。

数据报类型的网络或更一般的与之关联的排队理论（queuing theory）中的拥塞控制问题仍然是这些年的一个主要研究课题，它甚至不太可能完全解决所有情况。在这里讨论关于流
量控制的所有选择和方法也并不现实。有兴趣的读者可参考。在第16章我们将更详细地探讨实际用于TCP 中的拥塞控制技术，以及这些年来出现的许多变体。
\subsection{设置重传超时}
基于重传的可靠协议的设计者要面对的一个最重要的性能问题是，要等待多久才能判定一个分组已丢失并将它重发。用另一种方式说，重传超时应该是多大？直观上看，发送方在
重发一个分组之前应等待的时间量大概是下面时间的总和：发送分组所用的时间，接收方处理它和发送一个 ACK所用的时间，ACK返回到发送方所用的时间，以及发送方处理ACK
所用的时间。不幸的是，实际上这些时间没有一个是可以确切知道的。更糟的是，它们中的某些或全部会随着来自终端主机或路由器的额外负载的增加或减少而随时改变。

让用户去告诉协议实现在所有情况下的每个时刻应取什么超时时间（或使它们保持最新），这是不现实的，一个更好的策略是让协议实现尝试去估计它们。这称为往返时间估计
（round-tip-time estimation），这是一个统计过程。总的来说，选择一组 RTT样本的样本均值作为真实的 RTT 是最有可能的。注意到这个平均值很自然地会随着时间而改变（它不是静态
的），因力通信穿过网络的路径可能会改变。

做出对 RTT的一些估计之后，关于设置实际的用于触发重传的超时取值问题依然存在。如果我们回想一下均值的定义，会知道它绝不可能是一组样本的极值（除非它们全部一样）。
所以，把重传计时器的值设置成正好等于平均估计量是不合理的，因为很有可能许多实际的RTT将会比较大，从而会导致不必要的重传。很明显，超时应该设置成比均值要大的某个
值，但是这个值与均值的确切关系是什么（或者甚至直接就使用均值）还不清楚。超时设算得太大也是不可取的，因为这反过来会导致网络变得空闲，从而降低吞时准。对这个话题的
进一步探究留到第14 章，我们在那里会探讨 TCP是怎样实际地处理这个问题的。
\section{TCP的引入}
我们现在对影响可靠传输的问题有了大体的了解，下面看一下它们是怎样在 TCP 中体现的，以及TCP 会给互联网应用程序提供什么类型的服务。我们还要查看TCP头部中的字
段，了解有多少个到目前为止我们已经见过的概念（如ACK、窗口通告）可在头部描述中捕捉到。在随后的章节，我们会更详细地检查所有这些头部字段。

我们对TCP的描述从这一章开始，并在接下来的五章中继续讨论。第13章描述一个TCP连接是怎样建立和结束的。第14章详细说明 TCP是怎样估计每个连接的RTT 和怎样基
于这个估计设置重传超时的。第15章考察正常的数据传输，以“交互式”应用程序开始（例如聊天程序），然后是窗口管理和流量控制，这被应用于交互式和“大块”数据流（比如文件
传输）两种应用程序以及 TCP的紧急机制（urgent mechanism）一一宅允许发送方指定数据流中的某些数据作为特殊数据。第16 章考察 TCP 里的拥塞控制算法，这些算法在网络很繁忙
的时候帮助降低丢包率。这一章还讨论了一些改动，这些改动被提出来以增加快速网络的吞吐量或改进易损耗（如无线）网络的弹性。最后，第17 章显示 TCP 如何在没有数据流动时
保持连接的活动性。

TCP 的原始规范是\href{https://www.rfc-editor.org/rfc/rfc0793}{[RFC0793]}，尽管这个 RFC的一些错误已经在主机请求 RFC中被修改过来\href{https://www.rfc-editor.org/rfc/rfc1122}{[RFC1122]}。从那以后，TCP的一些规范就一直被修改和扩展以包含透明和改进的
拥塞控制行为 ［RFC568I］IRFC3782］\href{https://www.rfc-editor.org/rfc/rfc3517}{[RFC3517]}\href{https://www.rfc-editor.org/rfc/rfc3390}{[RFC3390]}\href{https://www.rfc-editor.org/rfc/rfc3168}{[RFC3168]}、重传超时 \href{https://www.rfc-editor.org/rfc/rfc6298}{[RFC6298]}\href{https://www.rfc-editor.org/rfc/rfc5682}{[RFC5682]}\href{https://www.rfc-editor.org/rfc/rfc4015}{[RFC4015]}、在 NAT 的操作『RFC5382］、确认行为 \href{https://www.rfc-editor.org/rfc/rfc2883}{[RFC2883]}、安全\href{https://www.rfc-editor.org/rfc/rfc6056}{[RFC6056]}
［RFC5927\href{https://www.rfc-editor.org/rfc/rfc5926}{[RFC5926]}、连接管理\href{https://www.rfc-editor.org/rfc/rfc5482}{[RFC5482]}以及紧急机制实现指导方针\href{https://www.rfc-editor.org/rfc/rfc6093}{[RFC6093]}。同时还有丰富的实验性修改，覆盖了重传行为\href{https://www.rfc-editor.org/rfc/rfc5827}{[RFC5827]}\href{https://www.rfc-editor.org/rfc/rfc3708}{[RFC3708]}、拥塞检测和控制 \href{https://www.rfc-editor.org/rfc/rfc5690}{[RFC5690]}
［RFCSS62］\href{https://www.rfc-editor.org/rfc/rfc4782}{[RFC4782]}\href{https://www.rfc-editor.org/rfc/rfc3649}{[RFC3649]}\href{https://www.rfc-editor.org/rfc/rfc2861}{[RFC2861]}以及其他特性。最后，在探究 TCP 如何利用多重并发网络层路径方面也做了工作 \href{https://www.rfc-editor.org/rfc/rfc6182}{[RFC6182]}。
\subsection{TCP服务类型}
虽然TCP 和 UDP使用相同的网络层（IPv4或IPv6），但是 TCP 给应用程序提供了一种与 UDP 完全不同的服务。TCP 提供了一种面向连接的（connection-oriented）、可靠的字节流
服务。术语“面向连接的” 是指使用TCP的两个应用程序必须在它们可交换数据之前，通过相互联系来建立一个 TCP连接。最典型的比喻就是拨打一个电话号码，等待另一方接听电
话并说“喂”，然后再说“找谁？”。这正是一个 TCP连接的两个端点在互相通信。像广播和组播（见第9章）这些概念在 TCP 中都不存在。

TCP提供一种字节流抽象概念给应用程序使用。这种设计方案的结果是，没有由TCP自动插人的记录标志或消息边界（见第1章）。一个记录标志对应着一个应用程序的写范围
指示。如果应用程序在一端写入10字节，随后写人20字节，再随后写人50字节，那么在连接的另一端的应用程序是不知道每次写人的字节是多少的。例如，另一端可能会以每次20
字节分四次读人这 80字节或以其他一些方式读人。一端给 TCP 输入字节流，同样的字节流会出现在另一端。每个端点独立选择自己的读和写大小。

TCP根本不会解读字节流里的字节内容。它不知道正在交换的数据字节是不是二进制数据、ASCII字符、EBCDIC 字符或其他东西。对这个字节流的解读取决于连接中的每个端点
的应用程序。尽管不再推荐使用，可TCP确实是支持以前提到过的紧急机制。
\subsection{TCP中的可靠性}
通过使用刚才描述过的那些技术的特定变种，TCP提供了可靠性。因为它提供一个字节流接口，TCP必须把一个发送应用程序的字节流转换成一组 IP可以携带的分组。这被称为
组包（packetization））。这些分组包含序列号，该序列号在 TCP 中实际代表了每个分组的第一个字节在整个数据流中的字节偏移，而不是分组号。这允许分组在传送中是可变大小的，并
允许它们组合，称为重新组包（repacketization）。应用程序数据被打散成 TCP 认为的最佳大小的块来发送，一般使得每个报文段按照不会被分片的单个 IP 层数据报的大小来划分。这
与UDP 不同，应用程序每次写入通常就产生一个 UDP 数据，其大小就是写人的那么大（加上头部）。由TCP 传给 IP的块称为报文段（segment，见图12-2）。在第15 章我们会看到
TCP 如何判定一个报文段的大小。

TCP 维持了一个强制的校验和，该校验和涉及它的头部、任何相关应用程序数据和IP头部的所有字段。这是一个端到端的伪头部校验和，用于检测传送中引人的比特差错。如
果一个带无效校验和的报文段到达，那么TCP 会丢弃它，不为被丢弃的分组发送任何确认。然而，TCP 接收端可能会对一个以前的（已经确认的）报文段进行确认，以帮助发送方计算
它的拥塞控制（见第16章）。TCP 校验和使用的数学函数与其他互联网协议 （UDP、ICMP 等）一样。对于大数据的传送，对这个校验和是否不够强壮的担心是存在的［SP00］，所以仔细的
应用程序应该应用自己的差错保护方法（如，更强的校验和或 CRC），或者使用一种中间层来达到同样的效果（如，见\href{https://www.rfc-editor.org/rfc/rfc5044}{[RFC5044]}）。

当TCP发送一组报文段时，它通常设置一个重传计时器，等待对方的确认接收。TCP不会为每个报文段设置一个不同的重传计时器。相反，发送一个窗口的数据，它只设置一个
计时器，当ACK 到达时再更新超时。如果有一个确认没有及时接收到，这个报文段就会被重传。在第14章我们将更详细地查看 TCP 的自适应超时和重传策略。

当TCP接收到连接的另一端的数据时，它会发送一个确认。这个确认可能不会立即发送，而一般会延迟片刻。TCP 使用的ACK 是累积的，从某种意义来讲，一个指示字节号N
的ACK 暗示着所有直到 N的字节（但不包含N）已经成功被接收了。这对于ACK 丢失来说带来了一定的鲁棒性—如果一个 ACK 丢失，很有可能后续的ACK 就足以确认前面的报文
段了。

TCP 给应用程序提供一种双工服务。这就是说数据可向两个方向流动，两个方向互相独立。因此，连接的每个端点必须对每个方向维持数据流的一个序列号。一旦建立了一个连
接，这个连接的一个方向上的包含数据流的每个 TCP 报文段也包含了相反方向上的报文段的一个ACK。每个报文段也包含一个窗口通告以实现相反方向上的流量控制。为此，在一
个连接中，当一个 TCP报文段到达时，窗口可能向前滑动，窗口大小可能改变，同时新数据可能已到达。正如我们将在第13章所见，一个完整的TCP 连接是双向和对称的，数据可
以在两个方向上平等地流动。

使用序列号，一个 TCP 接收端可丢弃重复的报文段和记录以杂乱次序到达的报文段。回想一下，任何反常情况都会发生，因为TCP 使用IP 来传递它的报文段，I不提供重复消
除或保证次序正确的功能。然而，因为 TCP是一个字节流协议，TCP 绝不会以杂乱的次序给接收应用程序发送数据。因此，TCP接收端可能会被迫先保持大序列号的数据不交给应用
程序，直到缺失的小序列号的报文段（一个“洞”）被填满。

我们现在开始观察 TCP的一些细节。这一章将只介绍 TCP的封装和头部结构，其他细节出现在后面的五章中。TCP 可与IPv4或 IPv6一起使用，同时它使用的伪头部校验和（与
UDP的类似）在IPv4 中和IPv6 中都是强制使用的。
\section{TCP头部和封装}
图12-2显示了 TCP 在IP 数据报中的封装。
TCP 头部紧跟着IP 头部或 IPv6 扩展头部，经常是20字节长（不带TCP 选项）。带选项的话，TCP 头部可达60字节。常见选项包括最大段大小、时间戳、窗口缩放和选择性ACK

头部本身明显要比在第10章我们见过的UDP的头部更复杂。这并不很令人惊讶，因为TCP是一个明显要更复杂的协议，它必须保持连接的每一端知道（同步）最新状态。如
图 12-3所示。

TCP 头部。它的标准长度是20字节，除非出现选项。头部长度（Header Length）字段以32位字为单位给出头部的大小（最小值是5）。带阴影的字段（确认号（Acknowledgment
Number）、窗口大小（Window Size）以及ECE位和ACK 位）用于与该报文段的发送方关联的相反方向上的数据流

每个 TCP 头部包含了源和目的端口号。这两个值与IP 头部中的源和目的IP 地址一起，唯一地标识了每个连接。在TCP 术语中，一个IP 地址和一个端口的组合有时被称为一个端
点（endpoint） 或套接字（socket）。后者出现在\href{https://www.rfc-editor.org/rfc/rfc0793}{[RFC0793]} 中，最终被 Berkeley 系列的网络通信编程接口所采用（现在经常被称为“Berkeley套接字”）。每个 TCP 连接由一对套接字
或端点（四元组，由客户机 IP 地址、客户机端口号、服务器 IP 地址以及服务器端口号组成）唯一地标识。这个事实在我们观察一个 TCP 服务器是如何做到与多个客户机通信的时候将
会变得很重要（见第13章）。

序列号（Sequence Number）字段标识了 TCP 发送端到TCP 接收端的数据流的一个字节，该字节代表着包含该序列号的报文段的数据中的第一个字节。如果我们考虑在两个应用
程序之间的一个方向上流动的数据流，TCP 给每个字节赋予一个序列号。这个序列号是一个32 位的无符号数，到达2”-1后再循环回到0。因沩每个被交换的字节都已编号，确认
号字段（也简称ACK号或ACK字段）包含的值是该确认号的发送方期待接收的下一个序列号。即最后被成功接受的数据字节的序列号加1。这个字段只有在ACK位字段被启动的情
况下才有效，这个ACK位字段通常用于除了初始和来尾报文段之外的所有报文段。发送一个ACK是发送任何一个TCP报文段的开销是一样的，因为那个32位的 ACK 号字段一直都
是头部的一部分，ACK 位字段也一样。

当建立一个新连接时，从客户机发送至服务器的第一个报文段的SYN 位字段被启用。这样的报文段称为SYN报文段，或简单地称为 SYN。然后序列母字段包含了在本次连接的
这个方向上要使用的第一个序列号，后续序列号和返回的ACK号也在这个方向上（回想一下，连接都是双向的）。注意这个数字不是0和1，而是另一个数字，经常是随机选择的，称
为初始序列号（Iitial Sequence Number, ISN）。ISN不是0和1，是因为这是一种安全措施，将会在第13章讨论。发送在本次连接的这个方向上的数据的第一个字节的序列号是ISN加
1，因为SYN位字段会消耗一个序列号。正如我们稍后将见到的，消耗一个序列号也意味着使用重传进行可靠传输。因此，SYN和应用程序字节（还有FIN，稍后我们将会见到）是被
可靠传输的。不消耗序列号的ACK 则不是。

TCP 可以被描述为“一种带累积正向确认的滑动窗口协议”。ACK 号字段被构建用于指明在接收方已经顺序收到的最大字节（加1）。例如，如果字节1~1024 已经接收成
功，而下一个报文段包含字节2049~3072，那么接收方不能使用规则的ACK 号字段去发信告诉发送方它接收到了这个新报文段。然而，现代TCP 有一个选择确认（Selective
ACKnowledgment, SACK）选项，可以允许接收方告诉发送方它正确地接收到了次序杂乱的数据。当与一个具有选择重发（selective repeat） 能力的TCP发送方搭配时，就可以实
现性能的显著改善［FF96］。在第14章我们将会看到 TCP 是如何使用重复确认（duplicateackowledgments）以帮助它的拥塞控制和差错控制过程的。

头部长度字段给出了头部的长度，以32位字为单位。它是必需的，因为选项字段的长度是可变的。作为一个4位的字段，TCP 被限制为只能带60字节的头部。而不带选项，大小是20字节。

当前，为TCP头部定义了8位的字段，尽管一些老的实现只理解它们中的最后6位°。它们中的一个或多个可被同时启用。我们在这里大致提一下它们的用法，在后面的几章里再
对每个进行详细的讨论。

\begin{enumerate}
    \item CWR——拥塞窗口减小（发送方降低它的发送速率）；见第16章。
    \item ECE—ECN 回显（发送方接收到了一个更早的拥塞通告）；见第16章。
    \item URG紧急（紧急指针字段有效——很少被使用）；见第15章。
    \item ACK——确认（确认号字段有效——连接建立以后一般都是启用状态）；见第13章和第15章。
    \item PSH——推送（接收方应尽快给应用程序传送这个数据——没被可靠地实现或用到）；见第15章。
    \item RST—重置连接（连接取消，经常是因为错误）；见第13章。
    \item SYN—一用于初始化一个连接的同步序列号；见第13章。
    \item FIN—一该报文段的发送方已经结束向对方发送数据；见第13章。
\end{enumerate}
TCP 的流量控制由每个端点使用窗口大小字段来通告一个窗口大小来完成。这个窗口大小是字节数，从ACK 号指定的，也是接收方想要接收的那个字节开始。这是一个16 位的字
段，限制了窗口大小到65535字节，从而限制了TCP的吞吐量性能。在第15章我们将看到窗口缩放（Window Scale）选项可允许对这个值进行缩放，给高速和大延迟网络提供了更大
的窗口和改进性能。

TCP 校验和字段覆盖了 TCP 的头部和数据以及头部中的一些字段，使用一个与我们在第8章和第10章讨论的ICMIPv6与UDP使用的相类似的伪头部进行计算。这个字段是强制
的，由发送方进行计算和保存，然后由接收方验证。TCP校验和的汁算算法与 、ICMP和UDP（“互联网”）校验和一样。

紧急指针（Urgent Pointer）字段只有在URG 位字段被设置时才有效。这个“指针”是一个必须要加到报文段的序列号字段上的正偏移，以产生紧急数据的最后一个字节的序列
号。TCP的紧急机制是一种让发送方给另一端提供特殊标志数据的方法。

最常见的选项字段就是“最大段大小”选项，称为MSS。连接的每个端点一般在它发送的第一个报文段（为丁建立该连接，SYT位字段被设置的那个报文段）上指定这个选项。
MSS 指定该选项的发送者在相反方向上希望接收到的报文段的最大值。在第13 章我们将更详细地描述 MSS选项，并在第14章和第15章描述其他一些TCP选项。我们考查的其他普
通选项还包括 SACK、时间戳和窗口缩放。

在图12-2中我们注意到 TCP报文段的数据部分是可选的。在第13 章我们将看到当一个连接被建立和终止时，交换的报文段只包含 TCP 头部（带或不带选项）而没有数据。如
果这个方向上没有数据被传输，那么一个不带任何数据的头部也会被用于确认接收到的数据（称为一个纯（pure）ACK），同时通知通信方改变窗口大小（称为一个窗口更新（window
update））。当一个报文段可不带数据发送时，超时操作会因此而产生一些新情况。
\section{总结}
在有损通信信道上提供可靠通信的问题已经被研究了许多年。处理差错的两种主要方法是差错校正码和数据重传。使用重传的协议必须也要处理数据丢失，经常通过设置一个计时
来进行，同时还必须要给接收方安排一些方法来告知发送方它已接收了什么。判定等待一个ACK 要多长时间是比较棘手的，因为合适的时间会随着网络路由或端点上负载的变动而
改变。现代协议用基于这些测量值的一些函数来估计往返时间以及设置重传计时器。

不考虑设置重传计时器的话，当同一时间只有一个分组在网络中时，重传协议是很简单，但对于延迟很高的网络，它们的性能会很差。为了更有效率，在一个ACK 被接收到之
前，多个分组必须被注入网络中。这种方法更有效率，但也更复杂。一种管理这些复杂性的典型方法是使用滑动窗口，其中分组用序列号标志，窗口大小限制分组数量。当窗口大小基
于来自接收方或其他信号（比如被丢弃的分组）的回馈而改变时，流量控制和拥塞控制两者就都被实现了。

TCP提供一种可靠、面向连接、字节流、传输层的服务（通过使用许多这些技术而构建）。我们简单地看了 TCP 头部里的所有字段，了解到它们中的大多数都与这些可靠传递的
抽象概念有着直接关系。我们将在接下来的章节里详细考查它们。TCP把应用程序数据组包成报文段，发送数据时设置超时，确认被其他端点接收到的数据，给次序杂乱的数据进行重
新排序，丢弃重复的数据，提供端到端的校验和。TCP 在互联网中被广泛使用，不仅许多流行的应用程序使用它、例如 HTTP、SSHTLS、 NeB1OS （NBT--NetBIOS over TCP）、
Telnet、 FTP 以及电子邮件（SMTP），许多分布式文件共享程序（如，BitTorrent, Shareaza）也使用它。
\section{参考文献}
